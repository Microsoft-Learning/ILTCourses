Module

Module Title

Introduction to HTML5 Development\
 \

Module Information

Course Number

10953A\
 \

Course Title

HTML5 Programming\
 \

Product ID

<Add Product Id here\>\
 \

Module Number

1\
 \

Total Module Count

9\
 \

Language

English

Published PPT Location

\\InstructorDeck\_Sample\\Sample.pptx

Instructor Note

Classroom timing for this module should be as follows (rough estimate):

Lecture: 70 minutes

Demo: 30 minutes

Lab: 75 minutes

Total: 175 minutes

\
 \

Module Overview

Module Overview

HTML is the markup language that every web developer uses to structure
and present content on the Internet. CSS, Cascading Style Sheets, is
used to add styling and layout to web pages built using HTML. JavaScript
is the scripting language that takes static HTML and makes it dynamic.

This module introduces HTML development, presenting all the basics
needed to build a web site or application. It also introduces CSS and
JavaScript, which with HTML are the basis for web development. The last
lesson in the module introduces the jQuery JavaScript library, the most
popular JavaScript library at the time of writing.

Objectives

After completing this module, you will be able to:

o Explain HTML basics

o Explain what HTML5 is

o Explain CSS basics

o Explain JavaScript basics

o Explain the jQuery Library

o Identify the essential features of Visual Studio 2010 SP1 that are
required to start developing HTML5 web application projects

Instructor Note

The module is very long and introduces a lot of concepts to the
students. While it is important to deliver the content as a prerequisite
to all of the other modules in the course, if you see that the class has
advanced students you may deliver lessons 1 and 3 quickly. Even so, the
content of lesson 3 might be crucial, as it contains a lot of
information sometimes unfamiliar to JavaScript developers, such as
scopes, closures, and the **this** functionality.

\
 \

Lesson

Lesson Title

Overview of HTML

Lesson Overview

HTML is the building block of all the web sites and applications that
exists in the Internet. It is used, since its creation in 1991, to
create web pages structure. It is very simple and easy to learn and on
the other hand can be used to create sophisticated web sites like
Facebook or Twitter.

The lesson is dedicated to basic HTML development. It contains
information about what is HTML, what are HTML tags/elements and about
the main elements in HTML. Mastering HTML can help to understand how to
layout web pages and to create much better web sites and applications as
a result of that.

Lesson Objectives

o Explain core HTML basics

Instructor Note

Most of the Internet is made up of HTML web pages. HTML is a markup
language that was invented in 1991 and since then combined with the
Internet changed the world. It is the building block of every web site
and web application. Its power is its simplicity. The web page creator
needs to know how HTML tags work and how to apply them in order to
create a web page. This lesson is all about HTML. It contains a tour
around the language in order to make a solid baseline to the next
lessons and modules.

\
 \

Topic Core Content

Topic Title

What is HTML?

Manual Content

HTML was invented in 1991 by Tim Berners-Lee, a British computer
scientist, in order to publish his physics articles on the Internet. His
physics articles required a method for delivering pages made up of text
combined with images, as well as the ability to link the pages in a very
simple manner. The linking issue was achieved by converting specific
entities on the page to hyperlinks, which, when clicked, directed the
user to a different page. In the same year, Tim Berners-Lee also
invented HTTP as a standard for transferring the HTML pages over the
Internet, a standard that is still used today for the same purpose. The
combination of HTML and HTTP is the basis for today’s World Wide Web.

HTML is an acronym for Hyper Text Markup Language. It is not a
programming language, since it has no functions, variables, or flow
constructs. HTML is a language that expresses the structure of a web
page. It contains data in its markup, and metadata that instructs it on
how to display the data. HTML can include text, images, audio, video,
forms, and many ways to express how and what to display in the web page.
It can also contain hyperlinks, which connect pages to one another and
can redirect the user to other resources available on the Internet.

Slide Content

Instructor Note

HTML and HTTP were introduced by Tim Berners-Lee in 1991 and made a
revolution which exists until today. HTML itself is a static language
that describes the structure of a web page. Without browsers that know
how to render it and specifications that specify to the browser how to
render it HTML could not become the language that it is today.

Raise a discussion about the Internet and how it influences our lives to
show the importance of HTML.

\
 \

Topic Core Content

Topic Title

Working with Tags

Manual Content

HTML is all about markup. To create an HTML page, the developer must use
markup tags. Tags express HTML functionality and can enclose text or
other HTML tags. In order to use a tag, the developer must place angled
brackets (< \>) around its name to first create the opening tag. For
example: <head\>, <body\>, and <div\>. Most tags have a corresponding
closing tag, which is identical except for the addition of a forward
slash (/) after the first angled bracket. For example: <head\> and
</head\>. Most of the tags have a semantic which tells the developer
what is their purpose, and some tags affect their contents. For example
the <p\> tag indicates that its contents are a paragraph and should be
rendered as a paragraph; the <table\> tag indicates that its contents
are a table and should be rendered as a table, and so on. There are also
self-closing tags such as the image tag which do not have a
corresponding closing tag. In order to write self-closing tags you put a
slash (/) at the end of the opening tag. For example: <img/\> or
<input/\>.

Slide Content

Instructor Note

HTML is made of HTML tags. Every tag has its meaning and effect.
Sometimes tags are referred as HTML elements but an HTML element is
defined as the starting tag, tag’s content, and the closing tag.

\
 \

Additional Slide

Slide Title

Working with Tags

Slide Content

Image for PowerPoint Slide

Select an image file on your computer

<Add Slide Path here\>\
 \

Browse

Select True from the dropdown if final slide design exists within
PowerPoint (PPTX) file.

True

Instructor Note

HTML tags can include other tags, building a much more expressive
structure. Embedding one tag inside another creates a tree structure,
called DOM (the Document Object Model), which is discussed more
thoroughly in lesson 4.

**Lead-in Sentence**

The following is an example of embedding tags inside other tags.\
 \

**Code Title**

Embedding Tags

**Code Example Content**

\
 <div\>

<h3\> paragraph heading</h3\>

<p\>a paragraph</p\>

</div\>

<table\>

<tr\>

<td\></td\>

<td\></td\>

</tr\>

</table\>

Attributes express a behavior to apply to the tag, and are only placed
in the opening tag. There are many types of attributes, expressing the
identity of a tag, a style for the tag, or behaviors such as the type of
a tag (used for inputs for example). Here is an example of the use of
attributes:

<div id="container" class="container"\></div\>

This div tag has two attributes: one sets its id to “container,” and the
other sets its CSS class to “container.”

\
 \
 \

Topic Core Content

Topic Title

The HTML Document\
 \

Manual Content

The HTML document can be also be referred to as a web page. The document
describes the structure of the web page and gives the browser all the
necessary details about the elements that it will render for display.
Each HTML document can contain many groups of elements, such as:

· HTML tags – these give the browser instructions about the structure
and nature of the elements to be rendered.******

· CSS blocks – these give the browser instructions about the style and
layout that will be applied to the document. We will discuss CSS in
lesson 3.******

· JavaScript blocks – these give the browser instructions about the
scripts that the document can run. We will discuss JavaScript in lesson
4.******

· Plain text – text blocks that are rendered as content in the document.

An HTML document is composed of three parts:******

· An HTML element******

· A Head element, containing hidden metadata, scripts, CSS, and
more******

· A Body element, containing the contents of the document******

#### The HTML element

The HTML element is used as a container and the root of the HTML
document. It wraps the head and body elements which are mandatory
elements inside of it. The main attributes that can be used in the
element are dir and lang. The dir attribute defines the text direction
inside the document which can be rtl (right to left) or ltr (left to
right). The dir attribute’s default value is ltr. The lang attribute
specifies the base language of an element’s attributes or content. The
language will be used by the browser for rendering purposes such as how
to render a calendar or dates.

Here is an example of an HTML element:

<html lang="en" dir="ltr"\>\
 </html\>

In the example you can see that the language was set with en value which
indicates English.

You can read more about language and language codes (such as en in the
example) in the following link:
[Languages](http://go.microsoft.com/fwlink/?LinkID=241685)

#### The head element

The head element is responsible for holding all the****information
needed to render an HTML document. It contains elements such as a title,
keywords that might be useful for search engines, and other data
irrelevant to the document’s content.

In the <head\> you will nest a title element which represent the
document’s title. The title element is mandatory and is displayed by the
browser.

Another element that can be nested inside the head element is the meta
element. The meta element is used for meatdata which is used to express
data about the HTML document. The meta element can have two main
attributes: charset and name.

The charset attribute specifies the character encoding used by the
document. For example, it can use the utf-8 character encoding to
indicate that the document is encoded by the utf-8 code page. Here is an
example of the meta element with charset attribute:

<meta charset="utf-8" /\>

****

You can read more about character encoding declarations in the following
link: [Encoding](http://go.microsoft.com/fwlink/?LinkId=241723)

****

The name attribute must be used with congestion with the content
attribute. In this case the meta element indicates that it hold metadata
with the specified name which its content is in the content attribute.
There are standard metadata names such as application-name, author,
description, and keywords. This does not mean that you can’t use the
meta element for your own purpose. Here is an example of using the meta
element with the name attribute:

<meta name="keywords" content=" type face,font,fonts" /\>\
 <meta name="application-name" content="Contoso" /\>

There are other head elements such as link and script that are explained
later in this module.

#### The body element

The body element is responsible for holding the document’s content. The
content is rendered by the browser and displayed to the user.

Here is a simple example of an HTML document:

<!DOCTYPE HTML\>

<html lang="en"\>

<head\>

<meta charset="utf-8" /\>\
 <title\>An HTML document</title\>

</head\>

<body\>

<p\>Hello world!</p\>

</body\>

</html\>

This example starts and ends with the HTML tag, which contains all of
the HTML content, including the head and body elements.

· Inside the head element, there is a title element, which is the
document title to be displayed by the browser.

· Inside the body element is content consisting of a paragraph that
contains the text “Hello world!”

Slide Content

Instructor Note

You should describe in details what is the HTML document which is
constructed by the HTML, head and body elements.

Demonstration

Demonstration Title

Creating an HTML Document

Key Points

o Writing a simple HTML document

Content

This demonstration show how to:

o Create an HTML file

o Add the HTML, Head, and Body elements

o Populate the elements

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV**as **Admin**with the
password **Pa$$w0rd**

\2. Open a notepad.exe (use the Windows start menu -\> run -\> notepad
and press OK).

\3. Add the doctype element:

<!DOCTYPE html\>

****

****

\4. Add the HTML element under the doctype element:

**Lead-in Sentence**

The following is an example of adding the HTML element under the doctype
element.\
 \

**Code Title**

Doctype Element

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

</html\>****

****

\5. Create the head and body elements inside the HTML element:

**Lead-in Sentence**

The following is an example of creating the head and body elements
inside the HTML element.\
 \

**Code Title**

Head and Body elements

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

<head\>

</head\>****

<body\>****

</body\>****

</html\>****

****

\6. Add a title to the head element and some content to the body
element:

**Lead-in Sentence**

The following is an example for Adding a title to the head element and
some content to the body element.\
 \

**Code Title**

Head and Body elements

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

<head\>****

<title\>Your first HTML document</title\>****

</head\>****

<body\>****

<p\>Hello HTML!</p\>****

</body\>****

</html\>****

****

\7. Save the file as an HTML file

\8. Run the saved file by double-clicking it

Instructor Detailed Steps

\1. Log on to the virtual machine named **SEA-DEV**as **Admin**with the
password **Pa$$w0rd**

\2. Open Notepad

\3. Add the doctype element:

<!DOCTYPE html\>

****

\4. Add the HTML element under the doctype element:

**Lead-in Sentence**

The following is an example of adding the HTML element under the doctype
element.\
 \

**Code Title**

Doctype Element

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

</html\>****

****

\5. Create the head and body elements inside the HTML element:

**Lead-in Sentence**

The following is an example of creating the head and body elements
inside the HTML element.\
 \

**Code Title**

Head and Body elements

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

<head\>

</head\>****

<body\>****

</body\>****

</html\>****

****

\6. Add a title to the head element and some content to the body
element:

**Lead-in Sentence**

The following is an example for Adding a title to the head element and
some content to the body element.\
 \

**Code Title**

Head and Body elements

**Code Example Content**

<!DOCTYPE html\>****

<html\>****

<head\>****

<title\>Your first HTML document</title\>****

</head\>****

<body\>****

<p\>Hello HTML!</p\>****

</body\>****

</html\>****

****

\7. Save the file as an HTML file

\8. Run the saved file by double-clicking it, and show the students the
completed web page

Preparation

<Add Preparation Steps here\>

Instructor Note

The demo is very simple and shows the basic steps of creating an HTML
document. You can skip this demo if the students already have some basic
knowledge of HTML. If students ask about the doctype element, explain
that it will be discussed in the second lesson.

\
 \

Topic Core Content

Topic Title

Content Elements

Manual Content

HTML uses content elements, sometimes called container elements. These
elements are used to hold other HTML elements or text.

#### The Div Element

The most popular and useful content element is the div element. Div is
short for division (or section). It represents a section of the HTML
document and is used to group block-elements for styling purposes. When
one div is placed next to another in the HTML document, they are
rendered one on top of the other. The use of div is the same as that of
any other tag.

The following example is a division:

<div\>This is a division.</div\>

****

#### The Span Element

The span element is another container element that, unlike div, is used
to group inline elements. Span does not add anything to the display but
can wrap content and change its appearance with styling. Here is an
example:

<span\>This is a span.</span\>****

****

#### The Paragraph Element

The paragraph element is used to indicate the contents of a paragraph.
When the paragraph is rendered, the browser will add an empty line above
and below it. Paragraphs can hold most HTML elements. Here is an example
of a paragraph:

<p\>This is a paragraph.</p\>

You can omit the closing tag of a paragraph and browsers will still
render it correctly. Even so, it is considered a bad practice to omit
closing tags.

Slide Content

Instructor Note

Content elements are very important as containers for text or other HTML
elements. They are widely used combined with CSS in order to layout web
pages. You should explain to the students the difference between the
elements.

\
 \

Topic Core Content

Topic Title

HTML Images

Manual Content

One of the commonly used HTML elements is the image. The image tag has
no closing tag, unlike most other HTML elements. Instead, it links to a
location where the image can is stored. To create the link, the image
tag must have a src attribute containing the URL of the image.

Each image element submits a request to the location of the image. This
means that a web page containing 5 images will submit 6 requests: one
for the web page itself and 5 for the images. Use images very
thoughtfully since using images increases the loading time of the web
page.

If the image isn’t available or is missing, a broken link icon is
displayed with alternative text, indicated by the alt attribute.

Here is an example of the usage of an image element:

<img src="someimg.jpg" alt="Some Image" /\>

Slide Content

Instructor Note

Images are widely used and sometimes over used. You can tell the
students about things like CSS sprites and image caching in order to
decrease the amount of requested images.

\
 \

Topic Core Content

Topic Title

HTML Hyperlinks\
 \

Manual Content

One of the most important key features of the HTML specifications is the
ability to connect web pages and browse between one page and another.
This ability was introduced very early in the development of HTML since
it helped to group relevant content into a full web site or application.
This was achieved by using hyperlinks: HTML elements written into a web
page that can be used mainly to navigate from one page to another or to
create a bookmark inside the page. The <a\> tag, when it wraps text or
images, makes them into hyperlinks. When a pointer is moved over a
hyperlink, the pointer arrow changes into a small hand, indicating that
this is a clickable part of the web page.

Here is a simple example of a link:

<a href="some URL"\>a link</a\>

As seen in the example, the hyperlink element must make use of a href
attribute, indicating the destination of the hyper reference.

Another important attribute is the target attribute. This attribute
specifies where to open the linked page. For example the use of
“\_blank” will open a new window for the clicked link. The target
attribute can get the following values:

· \_blank – open the link in a new window or tab.

· \_self – open the link in the same window or tab. This is the default
value.

· \_parent – open the link in its parent frame.

· \_top – open the in the full body of the window.

Two other attributes are the name and id attributes. When these
attributes are used inside the link, they create an anchor behavior. The
anchor behavior is synonym for creating a bookmark in a page section. In
the following example, the first link is a bookmark, and the second link
takes the user to the bookmark when it is clicked:

<a id="bookmark"\>This is a bookmark</a\>\
 <a name="bookmark"\>This is a bookmark</a\>

<a href="\#bookmark"\>Visit the bookmark</a\>

Note that the link for visiting the bookmark has a \# prefix, telling
the browser to search for a bookmark with the name or id of “bookmark”.

The bookmark/anchor behavior is used mainly for the creation of the
“Table of Contents” section at the beginning of a very long document.

Slide Content

Instructor Note

Hyperlinks are a very important aspect of HTML. They provide the means
to browse from one page to another or inside the same page.

\
 \

Topic Core Content

Topic Title

HTML Tables

Manual Content

The HTML table helps to organize tabular data inside a table structure.
It is represented by the <table\> element which is a container for table
rows. Table rows, <tr\> elements, are divided into table cells (<td\>
elements). Every table cell (or **t**able **d**ata) can contain HTML
elements such as images, links, other tables and more.

**Lead-in Sentence**

Here is an example of a table.\
 \

**Code Title**

Table Element

**Code Example Content**

\
 <table\>\
 <tr\>\
 <td\>row 1, cell 1</td\>\
 <td\>row 1, cell 2</td\>\
 </tr\>\
 <tr\>\
 <td\>row 2, cell 1</td\>\
 <td\>row 2, cell 2</td\>\
 </tr\>\
 </table\>

To display a border around the table, a border attribute with a width
value in pixels should be added to the table. For example the following
table will have a 2 pixel border:

<table border="2"\>

</table\>

Tables can also contain table headers – <th\> elements. Table headers
are displayed bold and centered by most of the browsers. Tables can be
written without table headers. Here is an example of a table with table
headers:\
 \

**Lead-in Sentence**

Here is an example of a table with table headers.\
 \

**Code Title**

Table with Table Headers

**Code Example Content**

\
 <table\>\
 <tr\>\
 <th\>header 1</th\>\
 <th\>header 2</th\>\
 </tr\>\
 <tr\>\
 <td\>row 1, cell 1</td\>\
 <td\>row 1, cell 2</td\>\
 </tr\>\
 <tr\>\
 <td\>row 2, cell 1</td\>\
 <td\>row 2, cell 2</td\>\
 </tr\>\
 </table\>

In the W3C specifications for tables, it is written that “Tables should
not be used purely as a means to layout document content”. In the past,
tables were used for page layout, but this is very unpopular and as
written in the specification that isn’t recommended today. This is for
the following reasons:

· Tables are rendered only after the browser reaches the closing tag,
</table\>. This is because up to that point the browser cannot know how
many columns the table will have. This behavior slows down the
rendering, since the browser cannot display the first part of the
webpage while reading the rest.

· Tables create a lot of distraction for developers. Since tables have a
lot of structural elements, the pages they create are often heavier and
can sometimes be unreadable.

· The use of CSS styles is better for page layout and organization.

Slide Content

Instructor Note

Tables are a much misused HTML element. They are used sometimes to
layout web pages, which is not their purpose. You should emphasize to
the students what are the problems which tables might impose on web
pages.

\
 \

Topic Core Content

Topic Title

HTML Lists

Manual Content

There are three kinds of lists in HTML:

· Unordered lists (<ul\>)

· Ordered lists (<ol\>)

· Definition lists (<dl\>)

Every list element can hold one or more list items (<li\>).

**Lead-in Sentence**

Here is an example of an unordered list.\
 \

**Code Title**

Unordered List

**Code Example Content**

<ul\>

<li\>Item1</li\>\
 <li\>Item2</li\>

</ul\>

This code is rendered as a bulleted list:

· Item1

· Item2

**Lead-in Sentence**

Here is an example of an ordered list.\
 \

**Code Title**

Ordered List

**Code Example Content**

<ol\>

<li\>Item1</li\>\
 <li\>Item2</li\>

</ol\>

This code is rendered with numbers instead of bullets:

\1. Item1

\2. Item2

List items can hold any kind of HTML elements even other lists (which
will create a behavior of a nested list).

It is very common to use unordered lists as menus and list items as its
menu items.

Definition lists are a little bit different and used rarely. They don’t
use the <li\> element and use the <dt\> and <dd\> elements instead. The
<dt\> element defines the item inside a definition list and the <dd\>
element describes the item.

Here is how you would use the definition list:

<dl\>

<dt\>Coffee</dt\>

<dd\>- black hot drink</dd\>

<dt\>Cola</dt\>

<dd\>- black cold drink</dd\>

</dl\>

This code is rendered as follows:

Coffee

- black hot drink

Cola

- black cold drink

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Demonstration

Demonstration Title

Creating an HTML document with HTML Elements

Key Points

· Create a simple web page using HTML elements

Content

This demonstration shows how to:

· Create a new Empty Web Application in VS2010

· Add a new HTML file

· Add HTML elements such as table, unordered list and hyperlinks

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin**with the
password **Pa$$w0rd**

\2. Open Visual Studio 2010

\3. Create a new C\# ASP.NET Empty Web Application

\4. Create an HTML file

\5. In the HTML file’s body element add the following elements:

<div\>This is a division.</div\>\
 <div\> This is another division</div\>\
 <span\>This is a span</span\>

<span\>This is another span</span\>\
 <p\>This is a paragraph</p\>\
 <a href="http://www.microsoft.com"\>A link to Microsoft site</a\>\
 <table border="1"\>\
 <tr\>\
 <th\>header 1</th\>\
 <th\>header 2</th\>\
 </tr\>\
 <tr\>\
 <td\>row 1, cell 1</td\>\
 <td\>row 1, cell 2</td\>\
 </tr\>\
 <tr\>\
 <td\>row 2, cell 1</td\>\
 <td\>row 2, cell 2</td\>\
 </tr\>\
 </table\>\
 <ul\>

<li\>item1</li\>

<li\>item2</li\>

</ul\>

\6. Save the file as an HTML file

\7. Run the saved file and show the students the completed web page

Instructor Detailed Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin**with the
password **Pa$$w0rd**

\2. Open Visual Studio 2010

\3. Create a new C\# ASP.NET Empty Web Application

\4. Create an HTML Page

\5. In the HTML file’s body element add the following elements:

<div\>This is a division.</div\>\
 <div\> This is another division</div\>\
 <span\>This is a span</span\>

<span\>This is another span</span\>\
 <p\>This is a paragraph</p\>\
 <a href="http://www.microsoft.com"\>A link to Microsoft site</a\>\
 <table border="1"\>\
 <tr\>\
 <th\>header 1</th\>\
 <th\>header 2</th\>\
 </tr\>\
 <tr\>\
 <td\>row 1, cell 1</td\>\
 <td\>row 1, cell 2</td\>\
 </tr\>\
 <tr\>\
 <td\>row 2, cell 1</td\>\
 <td\>row 2, cell 2</td\>\
 </tr\>\
 </table\>\
 <ul\>

<li\>item1</li\>

<li\>item2</li\>

</ul\>

\6. Save the file

\7. Run the saved file and show the students the completed web page

Preparation

<Add Preparation Steps here\>

Instructor Note

The demo’s purpose is to show how to write simple HTML elements and
demonstrate how the browser renders them.

\
 \

Topic Core Content

Topic Title

Creating Forms

Manual Content

Most of the applications on the Internet have a server-side that handles
requests and sends responses back to the client. When there is a need to
pass data from the client side to the server, one of the ways to do it
is by means of a form. A form defines a collection of input items that
hold user-defined values. These items can include elements such as text
boxes, checkboxes, and radio buttons. All such input elements must be
enclosed inside a <form\> tag, which indicate that they are part of the
form and that their values are sent back to the server. The form needs
to include a means of submission (for example a submit button), which
submits the entire set of values when activated by the user.

****

#### The Form Tag

A form is constructed from the input elements defined between its
opening and closing tags. All values obtained from these input elements
are sent when the form is submitted by the user. The form main
attributes include:

· **Action** – a destination URL to which the form will submit its
information. The default value for the attribute is the current
document’s URL. For example:

<form action="http://someurl"\>…</form\>

· **Method** – the method by which the form is submitted. There are two
options: GET and POST. GET (or HTTP GET) is a method used to transmit a
HTTP request with the GET verb. All the names and values of the input
element are appended as a query string to the URL specified in the
action attribute. \
 \

Query string is data that is appended to the end of a page URL. They are
created by adding a question mark to the end of the URL and then a
name=value pair for each name and avalue separated by comma. Here is an
example of a query string:
[http://www.microsoft.com?a=1;b=2](http://www.microsoft.com?a=1;b=2). In
the example there are two parameters in the query string – a and b with
their values.

·

· POST (or HTTP POST) is a method used to transmit a HTTP request with
the POST verb. All the names and values of the input elements are sent
in the request header, which is a header of an HTTP request, to the
location specified in the action attribute. POST is preferred because it
doesn’t send bare data like GET does. Here is an example of a form tag
using the POST method:

<form action="http://someurl" method="POST"\>…</form\>

****

#### The Input Elements

There are many types of input elements. Input elements are defined
between the form tags. To use an **input** element, you must use an
**input** tag and specify the type of the input. If there is no type, or
the browser cannot recognize the type, a textbox input type is used as
the default.

Each input type must have a unique name. This restriction is necessary
because when a form is submitted the name of the input is sent to the
server with its data.

The most common input types are as follows:

**Text fields**: Input with the **text** type is rendered as a one-line
text field. Text fields are the most common input types. The text field
can receive any value that the user types inside of it. If the **value**
attribute is set, the text field is rendered with the given string as a
default value.

<input type="text" name="txtFirstName" value="John" /\>

**Radio buttons**: Radio buttons let the user select only one option
from a limited number of choices. The input’s type needs to be **radio**
in order to create a radio button. In order to group radio buttons, and
by doing so indicate that only one of the buttons in the group can be
selected, the developer must give them all the same value under the
**name** attribute. A **value** attribute must appear in each radio
button, defining the text that will appear beside the radio button when
it is rendered. At form submission, the list of name/value pairs sent to
the server will include a single pair representing the entire group of
radio buttons. In that pair, the name is the mutual name of the buttons,
and the value is that of the selected radio button. The **checked**
attribute may be added to one radio button from each group, to indicate
that it should be checked by default when the page is loaded. Here are
two radio buttons:

\
 <input type="radio" name="rdo" value="Yes" /\>\
 <input type="radio" name="rdo" value="No" /\>\

**Checkboxes:** Checkboxes let the user select options from a limited
number of choices. The input’s type needs to be **checkbox** in order to
create a checkbox. To show text beside the checkbox, a **value**
attribute must be supplied. When the form is submitted, the list of
name/value pairs sent to the server includes a name and value pair for
each checked check box. The **checked** attribute may be used to
designate that the checkbox should be checked by default when the page
is loaded. Here are two sample checkboxes:

\
 <input type="checkbox" name="chkYes" value="Milk" /\>\
 <input type="checkbox" name="chkNo" value="Cola" /\>\
 \

**Submit buttons:** Submit buttons are created with the **submit** input
type. The browser will render a button that, when clicked, constructs
the list of name/value pairs from all the input types in the same form
and sends it to the server. Here is an example of a submit button:

\
 <input type="submit" name="btnSubmit" id="btnSubmit" value="Click Me"
/\>\
 \

**Password field:** Has the same behavior as a text field, but displays
only asterisks instead of the text that is inputted.

\
 <input type="password" name="txtPassword" /\>\
 \

**Buttons:** This input type appears as a button in the web page. Each
button must have a **value** attribute that holds the text that is
displayed on the button’s surface. Buttons have no effect on form
submission and have no functionality by default. In order to add
behavior, an event handler must be wired to the button using JavaScript.
JavaScript is explained in lesson 4. Here is an example of a button:

\
 <input type="button" id="btnClick" name="btnClick" value="Click Me"
/\>\
 \

**Hidden field:**The hidden field is a text box which is not displayed
to the user. The hidden field value is not intended to be manipulated by
the user.

<input type="hidden" id="txtHidden" name="txtHidden" value="not
displayed to the user" /\>

**File input type:****The file input type represent a list of selected
file names. It is rendered as a textbox followed by a browse button.
Pressing the browse button opens a dialog that enables the user to
choose files to upload and send to the server. The files are not
uploaded up until the form is submitted.**

**<input
type=**"**file**"**id=**"**fileUpload**"**name=**"**fileUpload**"**/\>**********

**Reset button:****Reset buttons are created with the reset input type.
When reset button is clicked it reset all the form input types to their
default state. You can use the value attribute to write the**text that
is displayed on the button’s surface**like in all the other button input
types.**

**<input
type=**"**reset**"**id=**"**btnReset**"**name=**"**btnReset**"**value=**"**Reset**"**/\>**

#### Labels

Labels define a label for an input type. Labels have no effect on their
shown content. However they provide usability improvement for mouse
users since it will toggle the control when clicked. Labels should use
the attribute which need to hold the id of the input type related to the
label. Here is an example of a label and an input type:

\
 <label for="txtFirstName"\>First Name: </label\><input type="text"
id="txtFirstName" name="txtFirstName" /\>\
 \

****

#### Drop-Down Lists

Drop-down lists are created by the **select** element. They instruct the
browser to render a drop-down list that displays available options when
it is clicked. Each of the options is created by an **option** element.

**Lead-in Sentence**

Here is an example of a drop-down list.\
 \

**Code Title**

Drop-down list

**Code Example Content**

\
 <select\>

<option value="0"\>Male</option\>

<option value="1"\>Female</option\>

</select\> \
 \

Two attributes that you should get to know with drop-down lists are the
size and multiple attributes.

The size attribute gets a number that defines the amount of visible
options in the drop-down list. If the size attribute has a value greater
than 1 the drop-down list will look like a list box instead. The default
value of the size attribute is 1.

The multiple attribute is used to indicate that multiple options can be
selected in the drop-down list.

#### Fieldsets and Legends

Fieldsets are used to logically group form elements. It will also create
a border around all the fields of a form. A legend can be used to define
a caption for a fieldset.

**Lead-in Sentence**

Here is an example of a fieldset.\
 \

**Code Title**

Fieldset

**Code Example Content**

\
 <fieldset\>

<legend\>Client Info:</legend\>

<label for="txtName"\>Name: </label\><input type="text" id="txtName"
name="txtName" /\><br /\>

<label for="txtAddress"\>Address: </label\><input type="text"
id="txtAddress" name="txtAddress" /\>

</fieldset\> \
 \

Slide Content

Instructor Note

Forms help to gather data from the user and are used to interact with
the users. They are created using the form element and different input
types.****

\
 \

Demonstration

Demonstration Title

Creating Forms Using HTML

Key Points

· Create a simple web form

Content

· Create a new Empty Web Application in VS2010

· Add a new HTML file

· Add a form element

· Add a fieldset and a legend elements

· Add input types and labels

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin**with the
password **Pa$$w0rd**

\2. Open Visual Studio 2010

\3. Create a new C\# ASP .NET Empty Web Application

\4. Create an HTML file

\5. In the HTML file’s body element add the following elements:

<form action="\#" method="GET"\>\
 <fieldset\>

<legend\>Client Info:</legend\>

<label for="txtName"\>Name: </label\><input type="text" id="txtName"
name="txtName" /\><br /\>

<label for="txtAddress"\>Address: </label\><input type="text"
id="txtAddress" name="txtAddress" /\><br/\>\
 <input type="submit" value="Submit" name="btnSubmit" name="btnSubmit"
/\>

</fieldset\>\
 </form\>

\6. Save the file as an HTML file

\7. Run the saved file and show the students the completed web page

Instructor Detailed Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. Open Visual Studio 2010

\3. Create a new C\# ASP .NET Empty Web Application

\4. Create an HTML file

\5. In the HTML file’s body element add the following elements:

<form action="\#" method="GET"\>\
 <fieldset\>

<legend\>Client Info:</legend\>

<label for="txtName"\>Name: </label\><input type="text" id="txtName"
name="txtName" /\><br /\>

<label for="txtAddress"\>Address: </label\><input type="text"
id="txtAddress" name="txtAddress" /\><br/\>\
 <input type="submit" value="Submit" name="btnSubmit" name="btnSubmit"
/\>

</fieldset\>\
 </form\>

\6. Save the file

\7. Run the saved file and show the students the completed web page

Preparation

<Add Preparation Steps here\>

Instructor Note

The page will submit to itself and you should show the students the
query string that is constructed to the page’s URL.

\
 \

Lesson

Lesson Title

What’s New in HTML5?

Lesson Overview

HTML5 allows for the creation of much better web applications and web
sites. Using HTML5, web developers can expose graphics and multimedia to
web pages with no need for plugins, use advanced JavaScript APIs such as
client-side storages, arrange their web pages with a more meaningful
structure, and embed semantics in their content. This lesson explains
the past, present, and future of HTML5.

Lesson Objectives

o Explain what HTML5 is

o Explain the new HTML5 elements (structural elements, new form/input
elements, new attributes, new media content, etc.)

Instructor Note

This is only an introductory lesson to HTML5. The course will delve
deeper into the many features mentioned in this lesson. Try to deliver
the content on as high a level as possible.

\
 \

Topic Core Content

Topic Title

What is HTML5?

Manual Content

In 1991 the first HTML specifications were published.

The second release of HTML (HTML2) was published in 1995, introducing
form-based file uploads, tables, and more.

In early 1997 a new and improved HTML specification (HTML3) was
published as a W3C recommendation.

W3C is the World Wide Web Consortium. It is a consortium that was
established by Tim Berners-Lee, the HTML creator, and it is in charge of
creating all the HTML specifications.

Most of the changes in this version were the adoption of Netscape’s
visual markup tags.

In late 1997 the last HTML specification (HTML4) was released. This
version has changed a little over time but remained in use until 2007,
when the W3C and WHATWG began work on HTML5.

WHATWG is the Web Hypertext Application Technology Working Group. It is
a working group separated from W3C which its main issue is web forms.

**Image Caption**

HTML History\
 \

**Final Image File Path**

HTML.PNG

Browse

**Source Image File Path**

HTML.PNG

Browse

**Source Image File Instructions**

<Add Source File Instructions here\>\
 \

HTML5 is a product of two different groups that were working on
separate, but related, efforts:

o W3C - was working on HTML4****

o WHATWG - was working on web forms and web applications

These groups began to cooperate in 2006 to create a much better Web
experience. The product of their cooperation is HTML5. HTML5 is a new
set of standards and specifications that try to fix some problems with
the previous version of HTML such as the lack of guidelines, its loose
structure, and its lack of flexibility, and more.

Slide Content

Instructor Note

HTML5 is a product of two different groups:

o W3C - The World Wide Web Consortium\
 Was working on XHTML 2.0, and HTML4****

o WHATWG - The Web Hypertext Application Technology Working Group\
 Was working on web forms and web applications

These groups began to cooperate in 2006 to create a much better Web. The
product of their cooperation is HTML5. HTML5 is a new set of standards
and specifications that try to address some problems with the current
version of HTML such as the lack of guidelines, its loose structure, and
its lack of flexibility and more.

\
 \

Topic Core Content

Topic Title

The Doctype Element

Manual Content

The doctype is one of the important elements in any HTML document. It is
the first element that you include in an HTML document. It is used for
defining the document type declaration (DTD) which defines to the
browsers how to render the HTML document (this is called the Standards
Mode). At the beginning, it was created to enable HTML parsing and
validation by third party SGML tools. Current browsers don’t render HTML
as SGML applications and don’t read the DTD, but doctype is mainly used
for defining quirks mode. *Quirks mode* is a technique that browsers use
for backward compatibility. Because there are many browser versions (for
example Internet Explorer 6, Internet Explorer 7, Internet Explorer 8
and Internet Explorer 9), most of the browsers maintain a mode that
enables them to render web pages that were created for older browsers.
This ability is called the quirks mode. In HTML5 the doctype was
simplified into

<!doctype html\>

and it is not holding any DTD. Here is an example of using DTD in HTML4:

<!doctype html public "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd"\>

Slide Content

Instructor Note

Explain the importance of the doctype element which is defining to the
browsers in which mode to render the web pages.

\
 \

Topic Core Content

Topic Title

The New Elements in HTML5

Manual Content

HTML5 includes many new elements and features. There are approximately
100 different working groups that write its specifications, and this
mass of groups produces a lot of changes. Here are some of the new
elements of HTML5:

· **Canvas** – a drawing surface that enables drawing 2D graphics with
JavaScript API.

· **Video** and **Audio** – elements that enable the inclusion of
multimedia in web pages without the need for plug-ins such as Flash.
They also expose a JavaScript API that allows you to interact with them
programmatically.

· New content-specific elements – semantic elements such as **article**,
**footer**, **header**, and **nav** enable the developer to organize
content with more expressive elements.

· New form controls – new types of input elements were introduced. These
elements make it the browser’s responsibility to implement the behavior
of calendars, dates, and email addresses, freeing developers from having
to create the behavior themselves.

These new elements come with many new JavaScript APIs that enable
browser functionality not available before HTML5. This includes
determining the location of the browser by using the Geolocation API,
the use of files through the File API, and more.

Slide Content

Instructor Note

Explain in high level what are the canvas, video and audio elements,
what are the structural elements and the new input type. You can raise a
discuss about the necessity of new elements.

\
 \

Topic Core Content

Topic Title

HTML5 and the Open Web Platform

Manual Content

The Open Web Platform, or OWP, is a collection of web technologies and
standards developed by W3C and other web standardization bodies. OWP is
an umbrella term that W3C defined to cover standards such as HTML5,
CSS3, SVG, and most of ECMAScript’s APIs throughout 2011. W3C uses this
term in an attempt to differentiate between this set of technologies
(which many refer to as HTML5) and HTML5 proper (which is technically a
single, large standard written by W3C.

Slide Content

Instructor Note

<Add Instructor Notes here\>

Lesson

Lesson Title

Introduction to CSS

Lesson Overview

CSS is a simple language with a single purpose: to tell the browser how
to display web pages. All modern browsers support CSS and most modern
web sites use it. CSS can be used to define almost every aspect of a web
site’s presentation other than the content itself: fonts, colors,
general layout, and a consistent look and feel. CSS is integral to every
professional web developer’s tool chest.

In this lesson, you will learn the CSS basics that will enable you to
integrate CSS into your web pages. You will also learn about some of the
limitations of CSS and ways to resolve those issues.****

Lesson Objectives

o Describe the basic CSS selectors to be used in the course

Instructor Note

This lesson teaches students the rudimentary concepts necessary to
understand CSS and use it properly. It also introduces the syntax, a few
basic selectors, and some of the more common styles used on the Web.****

CSS is generally easy to grasp as a concept. However, students
encountering CSS for the first time often have two difficulties:

· First, CSS has quite a few properties. Even though they follow set
patterns and are designed to be discoverable, students can have
difficulty remembering all the property names and their possible values
and combinations. The best way to teach these, once they’ve been
introduced, is to practice them. Students should also be encouraged to
use the Developer Tools extensions and add-ons of various browsers.
These extensions can be a very effective hands-on teaching device that
facilitates exploration and experimentation with styles live in the
browser.

· Second, the selector syntax, which is terse, can seem overly
convoluted. This lesson tries to convey the flexibility afforded by CSS
selectors without overloading the students. It generally avoids less
common selectors in favor of clarity. For example, sibling, attribute,
and language selectors are not introduced, but students are taught to
combine and group selectors. Module 4, which introduces CSS3, will teach
a few of the more advanced selectors at the developer’s disposal.

This lesson does not introduce CSS3, which is introduced in Module 4. It
focuses exclusively on CSS 2.1.

CSS is conducive to visual demonstration, so this lesson uses a number
of short demonstrations.

\
 \

Topic Core Content

Topic Title

What is CSS?

Manual Content

#### Separation of Concerns: Page Content vs. Presentation

HTML is a *markup language* that ascribes meaning to content by wrapping
it with descriptive tags. CSS, on the other hand, is a *declarative
language* that defines the styles and layout that a browser should apply
to HTML elements matching specific conditions. There is a very clear
*separation of concerns*: HTML is about content, data and information,
while CSS is about presentation.****

CSS stands for *Cascading Style Sheets*. The term *cascade* simply means
that styles *accumulate*. Every rule that matches an HTML element adds
more style information that the browser can use to draw or lay out that
element. Properly designed web sites often contain multiple CSS files,
or *style sheets*. It is not uncommon for multiple rules across all of
these style sheets to match any given element. In fact, in addition to
the style sheets that a web site uses, every browser supplies a default
style sheet and users may supply their own as well.

Using multiple style sheets, where each style sheet targets a specific
aspect of the web site, is strongly recommended. For example, one style
sheet could supply styles for the general theme and another may supply
styles for a specific feature, like a cart or a menu. Separating these
styles into multiple files makes it much easier to manage the styles and
maintain them over time.

Thus style sheets may overlap. In other words, any number of rules can
match any given element, and these might declare conflicting styles. For
example, one rule might specify that all the text on the page is 24
pixels tall, while another rule might specify that headers should be 36
pixels tall. When the browser searches for all the styles that match a
given header, it therefore has to choose between the two sizes. The CSS
standard defines very clear rules of precedence that browsers (and
therefore web developers) must follow when they create the CSS.

Basically, specificity (or closeness) matters. The general rule of thumb
is that the more specific, or closer, a rule is to an element, the more
likely it is to take precedence in such a conflict. If all the style
sheets were to be laid out in the order they are declared, the rules
literally *closest* to the matching element are more likely to be
applied.

#### Declaration

There are a few places styles can be declared:

· Inline styles are declared in the **style** attribute of the **HTML**
tag. They are as close (technically, as “specific”) as they can possibly
be and therefore always take precedence.

**Lead-in Sentence**

The following example shows an inline style applied to a p (paragraph)
element.\
 \

**Code Title**

Inline Styles

**Code Example Content**

<p style="color: red;"\>This is a red paragraph.</p\>

· Styles declared in the **style** element in the **head** element apply
only to elements on the page.

**Lead-in Sentence**

The following example demonstrates the use of a style declared in the
style element that affects every p element on the page.\
 \

**Code Title**

The Style Element

**Code Example Content**

<html\>

<head\>

<style\>p { color: green; }</style\>

</head\>

<body\>

<p\>This is a green paragraph.</p\>

</body\>

</html\>

· Styles declared in external CSS files can be referenced with the
**link** tag and apply to the elements on every page that references
them.

**Lead-in Sentence**

The following example references a CSS style sheet using the link
element.\
 \

**Code Title**

Using the **link**Element

**Code Example Content**

<head\>

<link rel="stylesheet" href="styles.css" /\>

</head\>

#### Visual Studio Support

Though professional web developers tend to prefer writing their CSS
styles manually, Visual Studio offers a number of very helpful aids that
assist both new and experienced developers, including the CSS Properties
Window, the New Style Dialog Box, the Build Style Dialog Box, and
IntelliSense.****

Visual Studio’s Build Style Dialog Box is an especially handy tool to
find and edit many of the common CSS styles. Unlike many other CSS
editors, it does not introduce extraneous styles and avoids changing
existing code where possible. It also produces clean CSS. This makes it
one of the most intuitive CSS editors and its use is encouraged for
beginning web developers.

As programmers grow in experience, they learn to rely on IntelliSense
for code completion and style discovery, though the Build Style Dialog
Box remains a helpful tool.

#### Trial and Error

Editing a web site’s CSS is very much an exercise in trial and error.
Making a professional site that looks good takes time and effort and is
a gradual, iterative process. However, there are excellent tools
available to facilitate this process, including the Internet Explorer
Developer Tools that are bundled with Internet Explorer, starting with
Internet Explorer 8. These tools let web developers experiment with the
styles on the page live before copying their results to the style sheet
files.

#### Browser Compatibility

Another important thing to understand is browser compatibility. CSS is
an ever-evolving standard. Much of the standard was developed in
parallel to its implementation by browser vendors. So different browsers
have varying levels of compatibility with the standard, and, on
occasion, they have been known to interpret the standard differently.
Newer browsers are more compliant and compatible with each other than
ever, but differences still exist.

Web developers should always check to make sure their sites work
properly on all the browsers they wish to support.

Two common approaches web developers use to ensure at least minimal
compatibility are *progressive enhancement* and *graceful fallback*. The
two approaches are very similar conceptually, but are implemented
differently. Web developers that progressively enhance their site tend
to build the site with the minimal target browsers in mind and then add
support for more advanced features targeted to newer browsers. Web
developers that follow the graceful fallback approach tend to target the
newest browsers first, and use various solutions and tricks to ensure
things work properly on older browsers they wish to target.

Slide Content

Instructor Note

Once students understand the basic difference between HTML and CSS, many
other concepts follow easily. It is encouraged to discuss this
*separation of concerns* with the students and to emphasize it. The
concept applies to JavaScript as well, which is introduced in the next
lesson.****

The use of the word *close* to describe the rules of precedence as they
are applied across styles and style sheets is not used as a technical
term. It is an effective visual aid that helps students more easily
predict the cascade’s order of precedence.

It is important to stress that working with CSS requires a lot of trial
and error. This can be a source of frustration for programmers, so
explaining that this is part of the process helps set expectations.

CSS that is not supported by older browsers can be applied on the fly
using JavaScript, a process known as *polyfilling*. Modernizr, a
JavaScript library that is capable of doing this, is introduced in a
later module.

\
 \

Topic Core Content

Topic Title

Syntax\
 \

Manual Content

#### Basic Syntax

A CSS rule is composed of a selector and a set of style declarations.
The selector is a kind of query that the browser uses to find the HTML
elements that the styles in the rule should be applied to. Each style
declaration consists of a property name and a value separated by a colon
(:). The semi-colon (;) ends the declaration. Multiple style
declarations can be specified in a single rule.

**Lead-in Sentence**

CSS have the following basic structure.\
 \

**Code Title**

The Structure of a CSS Rule

**Code Example Content**

selector {

property: value;

}

##### Selector Syntax

HTML is a hierarchical document structure. This means that every element
has certain hierarchical relationships with its surrounding elements. An
element may have ancestors, descendants and siblings. CSS selectors
describe certain relationships that have to exist for a style to be
applied to an element.

**Lead-in Sentence**

The following example demonstrates a simple rule that applies a couple
of styles to the th element.

**Code Title**

Simple CSS Rule

**Code Example Content**

th

{

font-size: large;

background-color: orange;

}

This example contains a very simple CSS selector that instructs the
browser to find all the **th** (table header cell) elements in the page,
regardless of their position in the hierarchy. It then paints those
elements’ backgrounds orange and sets the font size to a large size.

Selectors are explained in more detail shortly.

##### Properties and Values

CSS has a large but finite list of properties. Every property has a very
specific well-defined behavior. Also, every property can have only
certain kinds of values. The names and values follow certain
conventions, so they are usually easy to remember. Visual Studio
supports IntelliSense and code completion for CSS properties and their
values, so finding (or discovering) properties and recalling their
specific constraints is easy.

No single browser recognizes all the CSS properties. And even among
browsers that recognize the same properties, they might not render them
quite the same way. The situation has improved in recent years and most
modern browsers interpret the same basic set list of CSS properties the
same way. However, the CSS standard is always in flux and new properties
or refinements of existing values are being introduced all the time. In
the interim period before a property becomes standardized and is
implemented more or less the same way by all the major browsers, each
browser vendor may introduce their own properties. These special
browser-specific properties are always prefix with a “vendor prefix”.
For example, a new CSS property that only Internet Explorer supports
might be called -ms-new-property. It is recommended to avoid these
vendor-specific properties unless you plan to maintain the site
actively, as the behavior might change unexpectedly.

CSS properties can very often accept multiple kinds of values. For
example, the **color** property value can be specified as a named color,
such as **orange** or **blue**, or as a hexadecimal color value, such as
**\#3bf**. Another example that highlights the flexibility of using CSS
is size units. Sizes, which are values that can be specified for many
properties, including **width** and **height**, can be specified in
absolute point or pixel values or in relative percentage values.

CSS always tries to “fill in the blank”. Every property has a default
value. Web developers only specify the minimal set of properties and
values that they need to achieve the design they want.

##### Shorthand Properties and Default Values

There are a large number of CSS properties, but they are generally
arranged by groups. For example, there are properties that affect the
font, so they are all named with a **font-** prefix (for example,
font-size, font-weight, font-family, etc.). These prefixed fonts are
called longhand properties. Longhand properties allow web developers to
declare very specific styles in a verbose manner.

Sometimes that verbosity in unneeded so shorthand properties can help.
Shorthand properties are shorter properties that can specify the
behavior for multiple longhand properties belonging to a single group in
a single terse declaration (for example, **font**).

Shorthand properties have a number of advantages:

· They consume less bandwidth than their longhand equivalents

· They are considered “cleaner” and more elegant

· They are easier to remember and to write

Shorthand properties unite a number of related properties into one
declaration. To facilitate even shorter declarations, the values can be
abbreviated as well.

**Lead-in Sentence**

For example, the following properties.\
 \

**Code Title**

Margin Specified Using Longhand Properties

**Code Example Content**

margin-top: 10px;

margin-right: 10px;

margin-bottom: 10px;

margin-left: 10px;

**Lead-in Sentence**

Can be rewritten using a single shorthand property as follows.\
 \

**Code Title**

Margin Specified in Full With the Shorthand Property

**Code Example Content**

margin: 10px 10px 10px 10px;

**Lead-in Sentence**

And can be shortened further by removing redundant sizes.\
 \

**Code Title**

Margin Specified in Most Abbreviate Form

**Code Example Content**

margin: 10px;

The property in the last declaration is shorthand for the four explicit
properties. Some of the Developer Tools extensions will only show the
expanded, longhand properties, even when the style sheet declares a
shorthand property.

The size in the last declaration is just one example. It is possible to
specify 1, 2, 3 or 4 of the sizes. If only one size is specified, it
applies to all the sides; if two or three are specified, they apply to
the margins in order beginning from the top in a clockwise direction,
and margins left unspecified are set equal to those on the opposite
side.

The same kind of shortening can be used for other properties as well,
including font, border, padding, and many others.

##### Naming Conventions and Case-Sensitivity

CSS should be written as though it were case-sensitive. The CSS standard
specifies that CSS is not case-sensitive, but not all browsers interpret
this in the same way. For example, some browsers rely on
case-sensitivity for pages that use the XHTML schema. In addition,
external resources referenced by CSS styles may require case-sensitivity
in all browsers.

Because different browsers interpret the case-sensitivity rules
differently, Web developers should always write CSS as though it were
case-sensitive. They should also follow common naming conventions.

The following is a list of the most common naming convention rules.

· HTML tag names in selectors and in HTML documents should be in
lowercase (for instance, **h1**, **table**, **a**).

· Class names should use lowercase (for instance, **.notice**,
**.footer**, **.menu**).

· Compound class names (class names with multiple words) should have
those words connected with hyphens (for instance, **.page-link**,
**.article-body**, **.very-important-notice**).

· Element IDs should use lower camel case (for instance, **\#logo**,
**\#mainNavigationMenu**, **\#errorSummary**).

· Class names and element IDs should be descriptive and easy to
understand.

#### Selectors

An HTML document is a hierarchical document, which the browser
represents as a tree of elements. Selectors are expressions that
describe hierarchical patterns, which are essentially relationships
between the elements in the tree. When the browser encounters a style
rule, it finds all the elements whose positions in the tree are
described by the pattern expressed by the selector. The browser then
applies the styles declared in that rule to those matching elements.****

##### By Tag Name

The simplest pattern is a Type Selector, which is an expression that
matches a tag name. For example, to instruct the browser that the text
in every paragraph element (denoted by the <p\> tag) in the page should
be green, the selector would simply be the tag **p**. (According to
common naming conventions, tag selectors should use lowercase.)

**Lead-in Sentence**

The whole style rule would look like this.\
 \

**Code Title**

A Type Selector

**Code Example Content**

p { color: green; }

##### By Class Name

Very often, web developers may wish to apply the same style to a number
of elements with different tags. For example, the web developer might
decide that important notices should use the color red, whether they are
in paragraphs, headers or links. Instead of applying the red color to
all the **p**, **a**, and **h1**through **h6** tags, the developer would
instead choose a name for the style. This name should be in lowercase,
preceded by a period (.), and should be hyphenated if it is more than
one word. This style will then be implemented by referencing its name
with the **class** attribute anywhere in the HTML where it is to be
used. Classes are vital for separating the UI from the content, because
they enable the use of agnostic styles that can be applied to an element
by intention, role, or semantic relationship, instead of an arbitrary
hierarchical structure.

**Lead-in Sentence**

The style is therefore first defined as follows.\
 \

**Code Title**

A Class Selector

**Code Example Content**

.important-notice { color: red; }

**Lead-in Sentence**

Following this, the matched HTML fragment could look like this.\
 \

**Code Title**

HTML Matched by a Simple Class Selector

**Code Example Content**

<p\>This paragraph is green because all paragraphs are green.</p\>

<p class="important-notice"\>But this paragraph is red because it uses
the "important-notice" class name.</p\>

##### By Element ID

In contrast to classes, element ID selectors match only the element with
the specified ID. The ID of an element is specified using the **id**
attribute, and must be unique in the HTML document. It is a violation of
the HTML standard to use the same ID on more than one element in a page.
Otherwise, the ID selector is much the same as the class selector
because it can match any element regardless of its tag. ID selectors are
often used for very specific elements that repeat on multiple pages,
including navigation menus and specific sections (such as page headers
and footers, or the page logo). They are generally faster, but their use
is discouraged for more general scenarios because they limit the
flexibility of the page design. Element IDs are very useful when working
with JavaScript. By convention, Element IDs should be camel-cased in
accordance with JavaScript naming conventions.

**Lead-in Sentence**

The following example uses the purple color for the page header.\
 \

**Code Title**

An Element ID Selector

**Code Example Content**

\#pageHeader { color: purple; }

**Lead-in Sentence**

The following example contains an HTML fragment matched by the previous
CSS selector.\
 \

**Code Title**

An HTML Fragment Matched By an Element ID Selector

**Code Example Content**

<h1 id="pageHeader"\>This is the Purple Page Header</h1\>

##### Grouping Selectors

It is often convenient to apply a common style declaration to multiple
selectors. For example, the designers might decide that both the page
header and the navigation links should be purple. It is strongly
discouraged to create class names for artificial relationships based on
common styles. For example, a class name called “purple” which could be
used on both the page header and the navigation links would violate the
separation of concerns. If the page design would suddenly call for a
different color, the web developer would be inclined to modify both the
CSS and the HTML. Our goal is to create a resilient separation that
would not require modifying the HTML for stylistic changes. A better
solution is to group different selectors in one style rule. Changing the
color would require modifying only the CSS. Grouped selectors are
separated by a comma. For example:

.nav-link, \#pageHeader { color: purple; }

##### Combining Selectors

A single selector can also combine multiple conditions. For example, a
designer might decide that important notices that appear in regular
paragraphs should be red, but that important notices that appear in
table cells should be orange instead. Instead of creating two different
classes for what are essentially, semantically, identical, the web
developer need only modify the CSS. To create combined selectors, they
need to be written adjacent to each other, with no spaces in between.

p.important-notice { color: red; }

td.important-notice { color: orange; }

These selectors can be read as logical AND conditions. For example,
apply the red color style to all elements that have *both* the “p” tag
AND the “important-notice” class. More conditions can be affixed. The
following example specifies that all elements with the “menu-link” class
name should be blue, except for elements that have the “a” tag AND the
“menu-link” class AND the “current” class. The class attribute can
specify multiple classes by separating them with spaces.

/\* CSS \*/

.menu-link { color: blue; } a.menu-link.current { color: black; }

<!-- HTML --\>

<a href="thispage.html" class="menu-link current"\>This page</a\><a
href="thatpage.html" class="menu-link"\>Some other page</a\>

##### Descendant and Child Selectors

Selectors are most powerful when they describe more complex
relationships between elements. A selector can be composed of multiple
selectors separated by various “combinators”. Combinators define the
relationships between the different selectors. The simplest combinatory
is a space, which denotes a “descendent” relationship. The pattern
“.menu a”, for example, matches every anchor element (denoted by the “a”
tag) that is a descendent of an element with the “menu” class name. The
following CSS rule:

.menu a { color: yellow; }

Would match the first “a” tag because it is a child (an immediate
descendent) of the div with the “menu” class, the second “a” tag because
it is also a descendent of the “menu” div, but not the third “a” tag,
because it is a sibling of the “menu” div:

<div class=”menu”\>

<a href="Page1.html"\>Page 1: yellow</a\>

<ul\>

<li\><a href=”Page2.html”\>Page 2: yellow</a\></li\>

</ul\>

</div\>

<a href="Page3.html"\>Page 3: not yellow</a\>

If the selector used a child combinator, denoted by a greater than
symbol (“\>”), it would only match the first “a” tag. The second “a” tag
is not an immediate child of the “menu” div, so it will not be yellow.

.menu \> a { color: yellow; }

Finally, multiple combinators can be used. For example, a selector can
specify that a certain style should be applied only to “a” tags that are
children of a “li” tag that are descendents of a “menu” element:

.menu li \> a { color: brown; }

It is especially important to note that there is a difference between
the **div.class** selector (with no space) and the **div .class**
selector (with a space before the dot): the first is a single combined
selector and the second is a selector with two parts and a descendent
combinator. This is a common source of confusion for beginners.

#### Pseudo-Classes and Pseudo-Elements

Pseudo-classes and pseudo-elements are selectors of a different kind.
Instead of matching elements in the element tree based on information
that appears in the tree, they match elements based on other
criteria.****

##### Pseudo-classes

Pseudo-classes match elements based on certain states. For example, the
a (anchor) element can have the following four states: link, visited,
hover and active. It is possible to specify a different style rule for
each of these states. A pseudo-class is written as a colon (:) followed
by the pseudo-class name. It is not uncommon to see styles like this:

a:link { color: blue; }

a:visited { color: purple; }

a:hover { color: red; }

a:active { color: green; }

· The link state matches an element whose link has never been visited.

· The visited state matches an element whose link has been visited.

· The hover state matches an element *while* the mouse hovers over it.

· The active state matches an element *while* it is being clicked.

None of these states affect the element hierarchy. Note that for the
styles to be effective, they should be specified in the order in the
example.

Another common pseudo-class is the “first-child” pseudo-class. This
pseudo-class does match elements based on their position in the element
tree, but is still considered a pseudo-class because the fact that an
element is the first child of its parent is considered an arbitrary
state. The first-child pseudo-class is usually combined with a tag or
class selector. The following selector applies the orange color only to
the first paragraph of an article.

.article \> p:first-child { color: orange; }

##### Pseudo-elements

Pseudo-elements do not match elements; they match portions of elements.
Pseudo-elements are fictitious elements that often require unique styles
but cannot be represented using markup. For example, it is common to use
small-caps for the first line of an article or book chapter. Because
different screens, browsers, fonts, zoom levels and other factors are
beyond the control of the web developer or content editor, it is
impossible to know how much text appears on the first line before it is
actually rendered. The “first-line” pseudo-element solves that problem
by explicitly instructing the browser to match the text that appears on
the first line it actually renders.

The first-letter pseudo-element is similar to the first-line pseudo
element. While it is technically possible to create a real element for
the first-letter, it is often inconvenient and requires unnecessary
effort. The first-letter pseudo-element allows designers to create fancy
styles similar to those that appear in many printed books and magazines.
The following rule draws only the first letter of the first paragraph of
any article red:

.article \> p:first-child:first-letter { color: red; }

The before and after pseudo-elements let the CSS author add content to
the page without modifying the HTML or affecting the element tree. The
before and after pseudo-elements are generated elements (that do not
appear in the element tree) that are placed before and after the
matching element in the natural flow, respectively. They are often used
to add helpful icons that are not part of the page content. The before
and after pseudo-elements are usually specified with the content style
property. The following example adds a small image after the content of
every a element that has the “external-link” class, which is a helpful
indication to the user that the link references an external resource not
managed by the current site.

a.external-link:after { content: url(/images/externallink.png); }

Slide Content

Instructor Note

Selectors are discussed in more depth in the next topic. For this topic,
it is enough to demonstrate that a simple tag selector creates a rule
that matches all elements with that tag. The same goes for units, which
are covered explicitly in the next few slides. The important thing to
focus on here is the style block with the “property: value;” syntax.

The students should become accustomed to writing shorthand properties
and “expanding” them in their mind. They should also be able to expand
them as needed when more verbosity is necessary.

This topic introduces some of the more commonly used selectors available
in CSS 2.1. Some of the more advanced CSS3 selectors are introduced in a
later module.****

The most important items in this topic, by far, are the three basic
selectors: tag, class, and id. Once students understand these three,
they can learn to group and combine them to express more complex
patterns.****

Students that have difficulty with complex patterns can be taught to
“read” the expression as though it were a query. For example, the
selector div can be read as “Find all elements that have a **div**tag”.
The last selector above .menu li \> a can be read as “Find all the **a**
elements that are children of any **li** element that is a descendent of
any element with the menu **class**”. Another way to understand them
understand them is to split the pattern up into its constituent parts.
For example, the pattern .menu a.current applies to elements that match
all of the following criteria:

· They are **a** elements.

· Their **class**attribute is “current”.

· They are descendants of any element with the “menu” **class**.

Reading them in this way helps students visualize the relationships
expressed by the selector patterns.

\
 \

Topic Core Content

Topic Title

Common Styles\
 \

Manual Content

CSS defines too many style properties for us to cover all of them. This
topic covers some of the most commonly used styles, especially those
used to control background and text. Additional common styles are
covered in the Layout topic.

#### Background

There are quite a few style properties for specifying the background of
an element.****

##### The background-color Property

The **background-color** property specifies the background color of an
element. Its value is any valid color value, which is discussed shortly.

##### The background-image Property

The **background-image** property lets the user specify any image as the
background. If the **background-image** is specified after the
**background-color**, the image is visible above the color. The color is
visible through any “holes” in the image, whether due to transparency or
(possibly intentionally) mismatched dimensions. It is also visible
before the image is loaded. The value of a **background-image** property
is a url value. The following example specifies that the background is
blue wherever the background.png image is not visible.

body

{

background-color: blue;

background-image: url('/images/background.png');

}

##### The background-repeat Property

By default, the dimensions of the background image are not modified
based on the dimensions of the element. Instead it is tiled across and
then down to fill the background completely. Both tiling and position
can be changed. The **background-repeat** style affects the tiling and
can have one of the following values: “repeat”, “repeat-x”, “repeat-y”
or “no-repeat”. The default value is “repeat” which instructs the
browser to tile the image both horizontally and vertically.

##### The background-position Property

The **background-position** style specifies where to place the image
initially. Its value consists of two parts: the horizontal and the
vertical positions, which can each be specified by name (left and right,
top and bottom, and center), absolute pixels or percentage. The
following example shows the element once (with no tiling) and indent it
so it starts at 20 pixels to the right of the left edge of the element
and close to the top:

body

{

background-repeat: no-repeat;

background-position: 20px top;

}

##### The background Property

Many groups of related styles in CSS can be expressed using a *shorthand
style property*. The **background** shorthand style property can specify
all of these styles in one terse declaration. As with most shorthand
properties, CSS is very forgiving, so neglecting to specify one or more
of the constituent property values will results in default values being
used in their place. IntelliSense in Visual Studio can help remember
which properties are available and the correct order of the values.

body { background: url('/images/background.png') 20px top no-repeat; }

#### Text

HTML is a markup language that is primarily designed to mark up text.
CSS exposes many style properties specifically for text that can provide
very fine control over textual display.****

The most significant properties are the various font properties. The
shorthand **font** property can be used to declare them in one fell
sweep, just as the shorthand **background** property can declare the
various background properties together.****

##### The font-family Property

The **font-family** property selects the general font used to draw the
text. Because different browsers on different platforms and devices
recognize different fonts, the **font-family** property accepts multiple
values separated by commas. If the first font is unavailable, the
browser tries the next, until it finds one it recognizes. If it does not
find a font, it uses whatever the current font happens to be. This is a
fallback system, so the text is always rendered even if no specified
font is found. Any number of font families can be specified as
fallbacks.

Every browser is equipped with generic font families, which are general
mutually exclusive categories that every font family can be categorized
by. The most common generic families are “serif”, “sans-serif” and
“monospace”. Serif fonts are relatively ornate fonts that have
embellishments at the tips of the letters, such as Times New Roman, the
archetypal serif font. Arial is a sans-serif font, a font with simple
line endings and no embellishments. Monospace fonts are fonts in which
every character has the same width and height. The “cursive” and
“fantasy” generic fonts are rarely used.

Every **font-family** declaration should be suffixed with a generic
family so the browser can use a default font that belongs to the same
family if the requested font family is unavailable. The following
declaration specifies that the page should use the Arial font or
whatever sans-serif font it has if Arial is missing:

body { font-family: Arial, sans-serif; }

##### The font-size Property

The **font-size** property can specify an absolute value, such as “36px”
or “30pt” or “large”, or a relative value, such as “150%” or “larger” or
“1.5em”. Relative sizes are relative to the size of the containing
parent element. Units are discussed in the next topic.

##### The font-style Property

The **font-style** property specifies whether the font is “normal”,
“italic” or “oblique” (another italicized variant).

##### The font-weight Property

The **font-weight** property specifies the thickness, or darkness, of
the text. It can accept absolute values, such as “bold”, or a relative
value, such as “bolder”. The absolute value can also be a number between
100 and 900 (only round numbers divisible by 100).

##### The text-decoration Property

The **text-decoration** property specifies whether to draw a line under,
over or through the text. It accepts the values “none” (no line should
be drawn), “underline”, “overline” and “line-through” (effectively
strikethrough”). It is strongly recommended not to use the additional
“blink” value specified in the standard, which is not supported by all
browsers and generally considered a bad practice. Anchors (“a” tag) use
the “text-decoration: underline” declaration by default.

##### The text-align Property

The **text-align** property defines the horizontal alignment of the
text. It is only effective in block elements and cannot affect the
vertical alignment. Its value can be “left”, “right”, “center” or
“justify”.

#### Colors

The **color** property specifies the foreground color of the text. To
draw a highlight, use the **background-color** property. There are a
number of ways to specify colors in CSS.

· Use the name of a known color: red

· Use a 3-digit RGB value: \#f00

· Use a more precise 6-digit RGB value: \#ff0000

· Use the rgb function with absolute values: rgb(255, 0, 0)

· Use the rgb function with percent value: rgb(100%, 0%, 0%)

All of these examples represent the same color. CSS provides another
option based on “system colors” which is inconsistent across browser
implementations and should not be used. CSS3 adds additional options,
which is covered in a later module.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Lengths and Units

Manual Content

#### Overview

When a browser lays out an HTML document, it primarily tries to let the
content “flow” naturally. Text and images, for example, fill up the
available space and the browser breaks lines as necessary. When the
browser window is resized, the content is repositioned so it continues
to flow. HTML layout is designed with the assumption that the dimensions
of the output medium (the screen or printer) are not necessarily known
ahead of time.****

The main repercussion of this layout model is that precise control over
the lengths and dimensions of various elements is very difficult. Web
designers and developers have to account for the great variations
between, for example, large desktop monitors and tiny mobile screens and
printers of various sizes. It can be quite a challenge to style a web
page so it looks good in all these different form factors.

CSS allows developers to specify lengths in absolute and relative terms,
using many different measurement units. These lengths can be applied to
almost every element, including text and images, block and inline
elements, as well as the body and pseudo-elements.

Every number in CSS that denotes a size or length must have a unit
designation. Unit designations are affixed to the number values without
a space. So 10 pixels is denoted as "10px". Note that many sites use a
mixture of units, including pixels, ems, percentages and others. Some
units denote absolute sizes and others denote relative sizes.

The number 0 is an exception and does not require a unit. However, it is
best practice to specify units for 0 anyway.

#### Pixels

The most common unit of measure is the pixel, an absolute size denoted
by the “px” suffix. The actual size of a pixel depends on a number of
factors, including the device’s screen resolution and the zoom level in
the browser. Pixel sizes vary between devices, monitors, operating
systems and browsers. Despite these differences, pixels are still
considered the most viable option for specifying sizes, mainly because
they produce relatively predictable results.

#### Points and other absolute units

Points, denoted by the “pt” suffix, are not used as often as pixels.
They are usually used for text because fonts in operating systems, word
processing applications and print use points as their base unit of
measure. Fonts have also traditionally tended to look better when their
size is specified in points because they don’t need to scale by
fractional values. HTML documents often use points to specify font
sizes.

Points in CSS have a very specific size: they are defined as being equal
to 1/72^nd^ of an inch. CSS also defines additional absolute sizes,
including millimeters (mm), centimeters (cm), inches (in) and picas (pc)
which can all be converted to points very easily. These units are all
available in CSS, but their use is discouraged except in very specific
cases.

Though points and other absolute units produce very accurate results
when printed, they are not as accurate on screen due to the great
variation in monitor resolutions and operating systems. Browser
implementations for pixels vary, and they don’t scale well for screen
readers or mobile browsers.

#### Percentages

Percentages, denoted by the percent symbol (%), are relative sizes.
Whenever a percentage is specified, the browser calculates the actual
size based on the size of its parent. Judicious use of absolute and
relative sizes helps produce layouts that are easier to resize as needed
and take accessibility into consideration.

#### Ems

Ems, denoted by the “em” suffix, are another relative size unit. Unlike
percentages that are calculated relative to the size of the parent, ems
are calculated based on the current font size. They are specified
multiples of the current font size. If the font size is 12 points, for
example, **1em** = **12pt**, **2em**= **24pt**, and **0.5em**= **6pt**.

Ems are extremely useful on web sites that present a lot of text,
because they make layout more predictable. For example, if the width of
a paragraph containing text is specified as 30%, the amount of text that
fits on one line changes from browser to browser and monitor to monitor.
But if it is specified as 20em, every browser on every monitor displays
the same number of characters on one line.

Slide Content

Instructor Note

\
 \

Topic Core Content

Topic Title

Layout\
 \

Manual Content

#### The CSS Box Model

##### Content

When the browser renders HTML elements, it uses the concept of a box to
lay it out. Each element is rendered as though it were a rectangular box
with multiple outer layers, like a gift box wrapped with several layers
of wrapping paper. Whatever is written inside the HTML element is the
content of the element and is drawn in the inner-most box. The content
box is surrounded by a few layers, each of which has a specific role in
the box model.

The size of the inner content area ultimately defines the size of the
rendered element. The browser tries to render the element in the
available space if no size styles are specified. CSS provides a number
of styles that can be used to define the size of an element’s content.
The style properties that determine the size of the content itself are
**width** and **height**. Any size unit can be specified for them. In
the example below, the browser renders the size of any element with the
“footer” class name at 80% of the width of the element’s parent’s
content width and as high as 4 characters (in whatever their actual size
happens to be) stacked one on top of the other.

.footer

{

width: 80%;

height: 4em;

}

The browser may not always be able to render the content at the
requested size. It provides a few style properties that can help
determine limits for the browser. The min-width, max-width, min-height
and max-height properties provide the browser with hard limits. They can
be used to lay content out in a flexible manner that stretches
gracefully as the browser window expands and shrinks without ruining the
visual appeal of the site. The following example renders the
“main-content” area of the page at 80% of the available width, but
specifies the width should never be less than 300 pixels wide so it
cannot be hidden or made ugly by a too-small browser window. Note that
only a min-height property is specified for the height. This is a useful
technique to ensure that a content area is visible even when there is
little or no content.

.main-content

{

width: 80%;

min-width: 300px;

min-height: 400px;

}

If min-width or min-height are specified and the browser determines that
it does not have enough available space, it renders the element at the
width or height specified by the respective property and shows
horizontal or vertical scrollbars, respectively, on the browser window
to let the user scroll to see the hidden content.

##### Padding

The next layer outside the content area is the padding. Padding
specifies the amount of space between the edge of the content area and
the element’s border. The padding area shares the background of the
content area, so the following CSS specifies that the content should
have a blue background and the background color should extend 20 pixels
in all directions beyond the actual width and height of the content.

.main-content

{

background-color: blue;

padding: 20px;

}

The padding property is a shorthand property that abbreviates the
padding-top, padding-right, padding-bottom and padding-left properties.
When the shorthand property is used, CSS fills in longhand the property
values according to a very specific set of rules.

When only one measurement is specified, all sides receive the same
value, so **padding: 20px;** is equivalent to the following:

.main-content

{

padding-top: 20px;

padding-right: 20px;

padding-bottom: 20px;

padding-left: 20px;

}

Note that the sides are always specified in the same order: top, right,
bottom and left. This is a common convention in the CSS standard itself
for all properties that refer to the sides of an element.

When two measurements are specified, as in **padding: 20px 40px;**, the
first measurement refers to the top and bottom and the second to the
right and left. This is equivalent to:

.main-content

{

padding-top: 20px;

padding-right: 40px;

padding-bottom: 20px;

padding-left: 40px;

}

When three measurements are specified, as in **padding: 10px 20px
30px;**, the first size always refers to the top and the third always
refers to the bottom. The second size refers to both the right and the
left. This is equivalent to:

.main-content

{

padding-top: 10px;

padding-right: 20px;

padding-bottom: 30px;

padding-left: 20px;

}

Finally, when all four values are specified, they are assigned to the
sides in the normal order, so **padding: 10px 20px 30px 40px;** refers
to the top, right, bottom and left, in that order:

.main-content

{

padding-top: 10px;

padding-right: 20px;

padding-bottom: 30px;

padding-left: 40px;

}

Note that the same units were used for convenience. There is no such
requirement. Each of the sides can use any unit. It is legal, for
example, to specify **padding: 10px 20pt 30em 40%**.

##### Borders

Outside the padding is the border area. The border is specified using a
number of properties. Each side has a border and each border has a
width, a style and a color. The width is any ordinary size unit. The
color is any color unit. The style is one of the special border style
values. The most common border styles are “**none**”, which specifies
that there should be no border at all and is equivalent to setting the
border width to 0, “**hidden**”, which specifies that the border is
present but invisible and “**solid**”, which determines that the border
is visible as a single line.

Each side has its own set of properties that specify each of these
values. For example, **border-top-width**, **border-top-style** and
**border-top-color** specify all the properties of the top border. The
shorthand property border-top can be used to specify all three at once.
As usual, omitted values from the shorthand property are filled in with
default values. There are similar properties and shorthand properties
for the other sides as well.

.main-content

{

border-top: solid 1px red;

border-right: inset 2em \#0f0;

border-bottom: double 3% \#00ccff;

border-left: groove 4pt; /\* the color is filled in with the default \*/

}

Instead of specifying each side individually, the shorthand properties
**border-width**, **border-style** and **border-color** can be used to
specify all the widths, styles and colors, respectively of the entire
surrounding border. Each of these properties can specify one, two, three
or four values which are applied to the borders in the same order using
the same logic as the padding is applied to each side.

The last shorthand property is **border**. The **border** property can
be used to specify the same width, style and color for all the borders
and it is specified the same way **border-top** is specified. The
following CSS specifies that the entire element is surrounded by a
single solid green border 2 pixels wide.

.main-content

{

border: solid 2px green;

}

##### Margins

The last layer is the margin, which is outside the border. The margin
determines the amount of space between elements. Unlike the padding
which shares the background with the content area, the margin shares the
background with the content area *of the parent element*. The margin is
specified exactly the same way the padding is specified and has a
longhand size property for each side as well as a shorthand **margin**
property.

##### Offset

The area outside the margin is not really part of the box model but is
very useful for moving the element relative to its position in the
general flow. The offset property is very similar to the padding and
margin properties. The following CSS moves the element a bit to the
left.

.content-area

{

offset-left: -5px;

}

CSS contains quite a few properties that are specifically designed to
affect the layout of the elements on the page. Each layout property
affects the layout in a different way. This topic introduces the most
common and useful layout properties.

#### The display Property

The **display** property instructs the browser which layout algorithm to
use to lay out a specific element. Every element has a default layout
mechanism. Most elements are either inline elements or block elements.
The **display** property can be used to change the layout algorithm used
to render an element. The most common display values are “**block**” and
“**inline**”. The block display value specifies that an element should
be rendered as a block element, which means that the element should
start a new line, should take up as much space as it can horizontally
and that new content should appear beneath it. The inline display value
specifies that an element should be rendered in the normal flow, next to
the previous element, as though it were part of the text.

The div and span elements are the archetypal structural elements used
for controlling block and inline flow in a document. The div element
specifies, by default, that the display is “block” and the span
specifies “inline”. Using the display style property, these roles can be
reversed. The example is given to illustrate the switch; using the style
in this way is not recommended.

div

{

display: inline;

}

span

{

display: block;

}

Another useful display value is the “inline-block” value, which
instructs the browser to lay out the content inside the element as
though the element were a block element, but to position the element in
the document flow as though it were an inline element.

When display is set to “**none**”, it instructs the browser not to
render the element at all. The element is completely hidden and the
adjacent elements are rendered as though the element were not specified
in the document at all. This is useful for creating content that is
shown and hidden dynamically.

#### The visibility Property

The visibility style determines whether an element should be visible and
has three possible values: visible, hidden and collapsed. When
visibility is set to visible, it is rendered as it normally would be.
When it is set to collapsed, it is not rendered at all, as though
display were set to none. Finally, when the visibility is set to hidden,
the element is rendered and takes up as much space as it needs, except
that it is not visible. It affects the layout but cannot be seen.

#### The float and clear Properties

The float and clear properties complement each other. They each accept
the values “left”, “right” and “none”. The clear property also accepts
“both”. The float property instructs the browser to ignore the normal
position of the element in the document flow and to place it on the left
or right side of the content. To place a sidebar on the right side of
the page, the following CSS might be used:

div.sidebar

{

float: right;

}

When float is set to none, it instructs the browser to leave the element
in the natural flow.

The clear property has the opposite behavior. It instructs the browser
not to allow floats on the specified side, or on both sides. When clear
is set to “none”, floats can be placed on either side of the element.
When it is set to left, floats *cannot* be positioned to the left of the
content. Floats appear either above or beneath the element in these
cases.

#### Vertical Alignment

Text is notoriously difficult to align vertically using CSS. However,
text in table cells generally aligns vertically very well. In a table
cell, the vertical-align property can be set to “top”, “bottom”,
“middle” or “baseline”. Baseline is an imaginary line that is used to
lay out text with different font sizes at a common vertical position.

One technique to use to vertically align text that is not in a table
cell is to set the element’s display property to “table-cell”. The
following aligns text in every div to the bottom. Note that unrestricted
use of this technique is not recommended since the use of the
“table-cell” property value has other consequences.

div

{

display: table-cell;

vertical-align: bottom;

}

Another technique used to align text vertically is the use of the
line-height property. The line-height property specifies the height of
the line used to draw text. Usually the line height is directly related
to the font size, but when the line height is greater than the font
size, the text is automatically laid out vertically in the middle.

#### Overflow

When content is too large for the content box, the shorthand
**overflow** and longhand **overflow-x** and **overflow-y** properties
can be used to control what happens to the overflowing content. The
overflow properties can specify that the overflowing content should be
“visible” (the default value) or completely “hidden” from view. They can
also specify that a “scroll” bar should always be shown at the edges of
the content area to let the user scroll when there is overflowing
content. The last value, “auto”, instructs the browser to only show the
scroll bars if content really overflows. When the shorthand
**overflow**property is used, it implicitly specifies both of the
longhand properties. The **overflow**property is often used together
with the **max-width**and **max-height**properties that specify the
maximum size of the content area. The following example constrains the
size of the content area and adds a vertical scrollbar.

.content

{

overflow-x: hidden;

overflow-y: scroll;

max-width: 350px;

max-height: 200px;

}

Slide Content

·

Instructor Note

<Add Instructor Notes here\>

\
 \

Lesson

Lesson Title

Introduction to JavaScript

Lesson Overview

JavaScript is the programming language of the World Wide Web. It is the
only programming language supported by all modern desktop and mobile
browsers. Just as HTML describes the content of the page and CSS defines
its style and layout, JavaScript implements its behavior. This lesson
introduces JavaScript and teaches students how to create interactive web
pages, in accordance with current best practices.

Lesson Objectives

o Explain the basic JavaScript principles to be used in the course

Instructor Note

JavaScript has a unique combination of features usually found in very
different programming languages. These features were added to the
language for a number of reasons. One of the most important was to make
the language very easy to learn, not just for experienced programmers,
but also for newcomers and hobbyists.

The goal was to make building interactive web pages simple enough that
everyone could do it. This goal has been achieved with phenomenal
success. JavaScript is the most popular language on the Web. The great
majority of web pages use it and every modern browser supports it, so a
single JavaScript will most likely work the same in every browser. There
are some differences between browsers, but these are mostly minor and
there are simple well-known workarounds.

JavaScript’s immense popularity, the large number of non-professional
programmers and some of the features that make the language so easy to
learn have led to a profusion of programming styles and poor programming
practices. Over the past few years, many organizations and professional
programmers have been turning against these practices and have
introduced new JavaScript frameworks, standards and common conventions.

While anybody with minimal familiarity with JavaScript can use the
language, professional programmers can tap into its more advanced
features to create truly dynamic and highly-interactive web sites. HTML5
also introduces many new APIs that primarily target professional
programmers with a good understanding of the JavaScript language. Some
of these APIs are introduced in later modules.

This lesson teaches JavaScript to professional programmers. It quickly
covers the basics and then digs into some of the more advanced features
of the language. The lesson also draws the student’s attention to common
problems and best practices.

\
 \

Topic Core Content

Topic Title

What is JavaScript?

Manual Content

**Stepping Outside the Comfort Zone**

JavaScript has a unique combination of characteristics that programmers
should understand in order to use it effectively. Programmers whose main
experience is with static compiled programming languages, such as C\#
and VB.NET, should be aware that JavaScript represents a significant
departure from the kind of languages they are familiar with. There is
often a psychological barrier for experienced programmers who encounter
languages with any of the characteristics that JavaScript has. This may
require programmers to step outside their “comfort zone”. They should be
encouraged to use an open mind as they approach JavaScript and to learn
it as best they can before they pass judgment on it. Arguing over the
merits of the different programming paradigms before they are
well-understood is detrimental to the educational experience and should
be avoided.

**Language Characteristics**

JavaScript is a dynamic language. The program creates and modifies its
own types and structures at runtime, as the program executes. This
feature makes many otherwise cumbersome tasks trivial and has made
JavaScript very easy to use.

JavaScript is a scripting language. The browser parses and executes the
JavaScript code in the script files referenced by the HTML document and
they pass instructions to the browser.

JavaScript is an object-oriented language. Objects in JavaScript can
have properties and methods and they can interact with each other.
Because the language is dynamic, object structures are created and
modified dynamically, just like every other structure in JavaScript.
However, JavaScript is considered a classless system, so objects do not
derive from or extend classes. Instead, it has a different inheritance
system called prototypal inheritance, which is covered later in the
lesson. It is important to note that objects are optional in JavaScript,
which makes it easier for non-professional programmers to build simple
web sites. Programmers are strongly encouraged to use objects as much as
possible to write more robust and maintainable code. The proper use of
objects is crucial to building modern, complex and interactive web
sites.

JavaScript is a functional language. Functions are very powerful
constructs in JavaScript. They can be manipulated just like variables
and objects. They can be stored in variables and properties, they can be
passed around freely and they can be constructed dynamically and
executed anonymously. Unlike many functional languages, though,
JavaScript functions produce side-effects, are not immutable and lack
support for pattern matching and other features commonly associated with
functional programming languages. The relationship between functions and
objects in JavaScript is also unique, so understanding the way functions
work in JavaScript is vital to working with both.

**Browser Integration**

Anybody can read and modify the program while it runs in the browser.
All major browsers have tools and extensions, such as Internet
Explorer’s bundled Developer Tools, that make it exceptionally easy to
debug JavaScript code inside the browser. The Developer Tools have
interactive debuggers that support placing breakpoints on JavaScript
code inside the browser, tracking variables values with watches and
viewing the stack trace. The Developer Tools all have a Console feature,
which lets the user enter JavaScript code and commands directly into the
browser. The context in which code in the console is run is the same
context used to run all the code on the page. One useful debugging
technique is to add log statements to the code to track select
operations. These log statements appear on the console.

console.log("This statement appears on the JavaScript console.");

This feature is invaluable not only for debugging errant code, but also
for learning about the language. This lesson demonstrates many concepts
with code examples that can be entered directly into the console.

The browser hosts the JavaScript code and manages its execution and
interface with the HTML document. The browser’s JavaScript engine
parses, interprets (or JIT compiles) and executes the JavaScript. It is
also protective and limits JavaScript’s access to external services,
including the file system, to ensure malicious programs cannot damage
the end-user’s machine. JavaScript code only has access to the APIs
exposed by the browser.

Every modern browser creates an internal in-memory representation of the
HTML document and exposes that model as a hierarchical element tree
called the Document Object Model, or DOM. The DOM is designed to be read
and manipulated by JavaScript code. By manipulating the DOM, a
JavaScript programmer can modify almost every aspect of a web page, and
can even rewrite it completely on the fly. The DOM is the interface that
enables programmers to turn static HTML into a vibrant dynamic
interactive site. JavaScript and the browser have many features whose
goal is to facilitate interaction with the DOM.

Slide Content

Instructor Note

This lesson has some JavaScript code examples that print output to the
browser’s console. You should show the students how to open the Internet
Explorer Developer Tools (or an equivalent) and work with the console.

\
 \

Topic Core Content

Topic Title

Primitive Types

Manual Content

#### Five Primitive Types

JavaScript has five primitive types: boolean, number, string, null and
undefined. The primitive types are all immutable and are all passed by
value. The first three (boolean, number and string) also have
corresponding built-in objects called Boolean, Number and String,
respectively. It is important to note that the primitives and their
corresponding objects are designed to work together but do not behave
the same. The built-in objects are introduced in a later topic.

##### The boolean type

There are two Boolean values, **true** and **false**. Conditional
statements, such as if and while, evaluate Boolean values. Comparison
operators, such as greater than (\>), less than (<), equal to (==) and
strictly equal to (===) all return Boolean values. The following are
legal Boolean expressions:

true;

false;

true == true;

1 \> 0;

42 == "42"; // equal to -\> returns true

42 === "42"; // strictly equal to -\> returns false

##### The number type

All numbers in JavaScript are represented by the number type.
Internally, they are all 64-bit floating point numbers. This includes
whole numbers and decimal numbers as well as signed numbers and unsigned
numbers.

JavaScript supports several notations for numbers:

· Decimal (base 10) numbers are written normally (e.g., “4” or “4.5”).

· Octal (base 8) numbers are written with a “0” prefix (e.g., “010”).

· Hexadecimal numbers (base 16) are written with a “0x” prefix (e.g.,
“0x1F”).

· Scientific notation is also supported (e.g., “4e+3”).

JavaScript has a few special named numbers as well:

· Infinity – Infinity is a numeric value in JavaScript. It can be tested
for positive or negative infinity using the Math object. Dividing by
zero also produces the value Infinity.

· NaN – “Not a Number” is a numeric value in JavaScript. It is the value
returned when converting non-numeric strings and other values to
numbers. It is also given as the result of certain calculations.

JavaScript supports the common mathematical operators on numbers,
including addition (+), subtraction (-), multiplication (\*), division
(/) and modulus (%). It honors common mathematical operator precedence,
including parentheses. Many additional numeric operations can be
performed with the Math object, which is covered later.

The following expressions all represent legal numeric expressions in
JavaScript:

0;

1;

1.5;

+1.5;

-3.777777;

4 + -3.2;

9 % 2;

4e+3;

4e-3;

Infinity;

NaN; // represents a "Not a Number" value

1 / 0; // returns Infinity

Infinity; / Infinity // return NaN

010; // octal: returns the number 8

0x10; // hex: returns the number 16

2 + 3 \* 4; // returns 14

(2 + 3) \* 4; // returns 20

9 % 2; // returns 1

##### The string type

JavaScript string values represent Unicode text. String literals can be
denoted by either double quotes or single quotes (apostrophes), so long
as the same character is used to open and close the string literal.
There is no character type in JavaScript; a character is simply a string
with one element.

The escape character is the backslash. To use a double quote or single
quote character in a string, escape it as follows: \\" or \\',
respectively.

Strings can be concatenated using the plus (+) operator. The String
object, which is covered later, provides many additional string
manipulation methods.

The following expressions all represent legal string expressions in
JavaScript:

""; // double quotes – the empty string

''; // single quotes – also the empty string

"Hello, world!";

"This string \\n has an escaped new line character";

"The secret is " + "42"; // simple concatenation

##### The null type

The null value in JavaScript is not the default value of unassigned
variables and properties, as it would be in most languages. That purpose
is served by the undefined value. The null value is a value the
programmer uses to explicitly denote an object with no value. It is
inapplicable to non-object types.

##### The undefined type

The undefined value is the default value given to variables and other
containers that have not been assigned a value. This applies to
variables, function arguments and object properties and methods. The
undefined value in JavaScript is very similar in meaning and behavior to
the null value in other languages. Usage of the undefined value is
demonstrated in the next topic.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Variables

Manual Content

Declaring variables is very simple. Variables are declared using the
“var” keyword:

var enigma;

When a variable is declared without being assigned a value, its type is
**undefined**. To check if a variable value is undefined, use the typeof
operator:

typeof enigma; // returns "undefined"

The typeof operator can be used to check the type of any value.

typeof true; // returns "boolean"

typeof 42; // returns "number"

typeof "mystery"; // returns "string"

However, its results are inconsistent, or at the very least unhelpful,
once objects are involved, as is explained when they are introduced. An
alternative method for checking types is also shown. Note that the
**typeof**operator is the only way to check if a variable has not been
declared at all, since every other method (including the alternative
method mentioned above) causes JavaScript to raise a ReferenceError.

**Lead-in Sentence**

The following example demonstrates the difference between using the
typeof operator to check an undeclared variable and trying to reference
an undeclared variable.\
 \

**Code Title**

Using and Checking Undeclared Variables

**Code Example Content**

if(typeof undeclared == "undefined") {

console.log("This variable has no value or has not been declared!");

}

isUndefined(undeclared); // this raises a ReferenceError even if the
isUndefined function exists

To assign a value, use the assignment (=) operator:

var enigma; // declaration

enigma = "mystery"; // assignment

The value can also be assigned while declaring the variable:

var enigma = "mystery"; // declaration and assignment

Once assigned, the value is stored inside the variable. In JavaScript,
only values have types; variables do not. When a variable is checked for
its type, it actually returns the type of its value. As JavaScript is a
dynamic language, a single variable can be assigned a value of any type
and then reassigned with another value of any type.

**Lead-in Sentence**

The following example shows how the type of a variable changes when its
value changes.\
 \

**Code Title**

Dynamically Changing a Variable’s Type

**Code Example Content**

var enigma;

typeof enigma; // returns "undefined"

enigma = true;

typeof enigma; // returns "boolean"

enigma = 42;

typeof enigma; // returns "number"

enigma = "mystery";

typeof enigma; // returns "string"

It is technically possible in JavaScript to declare a variable without
using the **var** keyword. However, this is not equivalent to a proper
declaration and does not have the same behavior. It usually has
unintended consequences, as is demonstrated in the topic on Scope, and
very often introduces difficult bugs. Omitting the **var** keyword is a
*very* bad practice and should always be considered an error. Never omit
the **var** keyword when declaring variables.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Functions

Manual Content

Functions are the most basic unit of reusable code in JavaScript. When a
function is called, the statements in the function are executed. Simple
JavaScript functions are very similar to functions in other languages,
while advanced JavaScript functions have some unique characteristics
that stand out among them.

#### Declaring Functions

The most basic JavaScript function is declared using the **function**
keyword followed by the function’s name, parentheses and braces.
Whatever code is placed between the braces (“inside the function”) is
executed when the function is called. Functions are called by writing
their name followed by parentheses.

// the function declaration

function doSomething() {

// code goes here

}

doSomething(); // calling the doSomething function

The function provides scope, so variables that are declared locally
inside the function are only available inside the function. Though this
point may seem trivial, it is actually quite important to understanding
some of the function’s more advanced functionality. This point will be
returned to shortly.

function doSomething() {

var data = "local variable";

console.log(data); // this is a legal expression – data is "in scope"

}

doSomething();

console.log(data); // data is undefined in this scope, so this statement
raises a ReferenceError

#### Passing and Returning Values

##### Function Arguments

Values can be passed to functions as arguments. Function parameters
(“formal arguments”) can be declared as a comma-separated list of names
between the parentheses. The arguments behave just like local variables
declared inside the function, though the **var**keyword is not used for
their declaration. The following function has two parameters called
**message**and **value**. Note that just like with variables, their
values can have any type. Arguments are passed to the function by
placing them in the parentheses when calling the function.

function logArguments(message, value) {

console.log(message); // prints "The secret is"

console.log(value); // prints 42

}

logArguments("The secret is", 42);

##### The arguments Keyword

Arguments in JavaScript are rather flexible. The number of arguments
passed to the function is not required to match the number of parameters
declared on the function. It is legal to pass *fewer* arguments than
were declared, in which case arguments that received no value are
**undefined**. It is also legal to pass *more* arguments than were
declared.

All the arguments passed to the function can be accessed through the
**arguments** keyword, which is available only inside functions. The
**arguments** keyword represents a special object that behaves similarly
to an array (but is not an array!) and contains a list of all the
arguments passed to the function, whether declared or not. One way to
think about the **arguments** object is as an implicit params object
that automatically includes arguments passed to declared parameters as
well. To determine the number of actual arguments passed to the
function, check the value of the **arguments.length**property.

function print(first, second) {

console.log(first);

console.log(second);

console.log(arguments.length);

console.log(arguments[0]); // refers to the "first" parameter

console.log(arguments[1]); // refers to the "second" parameter

console.log(arguments[2]); // has no corresponding parameter

}

print(1); // the following values are printed: 1, "undefined", 1,1,
"undefined", "undefined"

print(1, 2); // the following values are printed: 1, 2, 2, 1, 2,
"undefined"

print(1, 2, 3); // the following values are printed: 1, 2, 3, 1, 2, 3

The items in the **arguments** object are interchangeable with their
matching parameters. Modifying one modifies the other.

function print(value) {

console.log(value); // prints 1\
 console.log(arguments[0]); // prints 1

value = 2; // change the local variable value

console.log(value); // prints 2\
 console.log(arguments[0]); // prints 2

arguments[0] = 3; // change the value in the arguments object

console.log(value); // prints 3

console.log(arguments[0]); // prints 3

}

print(1);

Note that the **arguments** keyword is not a reserved word in
JavaScript. It can be overridden by declaring a local variable or a
parameter with the same name. This is a bad practice and should be
avoided.

function printOverwrittenArguments(arguments) {\
 console.log(arguments); // prints 1

console.log(arguments[0]); // prints “undefined” instead of 1

}

function printBuiltInArguments(value) {

var arguments = 2;

console.log(value); // prints 1

console.log(arguments[0]); // prints "undefined"

}\
 \
 printOverwrittenArguments(1);\
 printBuiltInArguments(1);

##### The return keyword

To return a value from the function, use the **return** keyword inside
the function. A value of any type can be returned. A function can
contain multiple **return** statements, though the first **return**
reached ends the function’s execution. If no return statement is reached
before the function exits, an implicit value of **undefined** is
returned. There is no such thing as a void function in JavaScript,
though the return value can always be ignored.

function isTrue(number) {

if(number === 1) {

return true;

}

if(number === 2) {

return false;

}

// implicit return undefined

}

console.log(isTrue(1)); // prints true

console.log(isTrue(2)); // prints false

console.log(isTrue(3)); // prints "undefined"

#### Passing Functions Around

##### Functions are Values

Functions in JavaScript are values, like any of the primitive types, and
can be stored in variables that can be passed around. To assign a
function to a variable, simply place its name, without the parentheses,
to the right of the assignment operator. To call the function using the
variable, simply append parentheses to the variable itself and pass any
arguments, as you would for a normal function call.

function doSomething(data) {

}

var functionReference = doSomething; // this stores a reference to the
"doSomething" function in the "functionReference" variable

functionReference(1); // call the "doSomething" function

Functions can also be passed to other functions.

function callFunction(functionReference) {

functionReference(); // call the "doSomething" function

}

function doSomething() {

}

callFunction(doSomething); // pass the "doSomething" function to the
"callFunction" function

##### Anonymous Functions

Functions can be created on the fly and assigned to a variable, without
being declared. Functions created in this manner are unnamed and are
called *anonymous functions*. In the following example, an anonymous
function is created and stored in the variable print. The function is
called the same way any function would be called.

var print = function(message) {

console.log(message); // prints "Hello"

}

print("Hello");

They can also be passed anonymously to other functions, and even to
other anonymous functions.

var callReferencedFunction = function(functionReference) {

console.log(functionReference()); // prints "World", the result of
calling the anonymous function stored in "functionReference"

}

// call the anonymous function stored in the "callReferencedFunction"
variable and pass it another anonymous function as an argument

callReferencedFunction(function() {

return "World";

});

##### The function type

To test whether a variable or argument contains a function, the typeof
operator can be used. Function values have the type “function”. As noted
earlier, the typeof operator can produce inconsistent results when
working with objects, so its use is discouraged.

function declaredFunction() {

}

var functionVariable = declaredFunction;

var anonymousFunctionVariable = function() {

}

console.log(typeof declaredFunction); // prints "function"

console.log(typeof functionVariable); // prints "function"

console.log(typeof anonymousFunctionVariable); // prints "function"

##### Nested Functions

Functions in JavaScript can be nested. That is, a function can contain
other functions, which are only available (are in scope) inside that
function. They are not available outside the parent function, though
nested functions can see other nested functions in the same scope.
Nested functions can also access variables and arguments from the parent
function.

function parent() {

console.log("inside parent");

var parentData = 1;

function nested() {

console.log("inside nested");

console.log("parentData is " + parentData);

}

nested(); // call the nested function

}\
 \
 parent(); // this call prints "inside parent", followed by "inside
nested" and then "parentData is 1"

nested(); // raises a ReferenceError, since there is no nested function
in the current scope

Because nested functions cannot be seen from outside the parent, they
very often are used to encapsulate behavior. However, it is important to
remember that functions, whether they are nested or not, are values in
JavaScript, so they are created and destroyed as necessary. Nested
functions are only created when their parent function is called. This
means if an outer function is called many times, the nested functions
are also created and destroyed as many times. Repeatedly creating and
destroying these functions affects performance.

While there are justified uses for nested functions, and very popular
frameworks like jQuery certainly make use of them, it is a best practice
to avoid them, if at all possible. There are a number of ways to achieve
similar behavior without hurting performance. The simplest is to move
the nested functions out of the parent function. The nested functions
are no longer hidden. Also, they won’t be able to see the local
variables and arguments of the parent function, so they have to be
passed directly. The advantage is that only one instance of the nested
function is created, which significantly improves performance.

function nested(data) {

console.log("inside nested");

console.log("data is “ + data);

}

function parent() {

console.log("inside parent");

var parentData = 1;

nested(parentData);

}

parent(); // this prints "inside parent", followed by "inside nested"
and then "data is 1"

nested(); // this prints "data is undefined"

A better technique to encapsulate behavior is to use objects, which are
introduced in the next topic.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Objects

Manual Content

#### What is an Object?

An object in JavaScript is a dynamic bag of variables and functions,
called properties and methods, respectively. Properties and methods can
be added to a single object. An object also inherits properties and
methods from its prototype. JavaScript does not have classes; prototypes
are JavaScript’s mechanism for inheritance.

#### Creating Objects

To create an object in JavaScript, use the **new** keyword with the
Object constructor.

new Object();

To store the object in a variable, simply assign it as you would assign
any value. Objects in JavaScript are reference types, so the variable
actually stores a reference to the object and not the object itself. So
two variables can hold a reference to the same object.

var first = new Object();

var second = first;

first === second; // returns true

Note that each call to new Object() creates a completely new object,
which is not equal to any other object.

new Object() === new Object(); // returns false;

Objects are much more useful with properties and methods, which are very
similar to variables and anonymous functions, except that they are
assigned to the object using dot notation (.). JavaScript is a dynamic
language and properties and methods are created by being assigned. The
same notation is used to read the properties and execute the methods.
The following snippet creates an object called “car” and adds a property
and a method.

var car = new Object();

car.speed = 0; // the speed property is created and initialized

// the drive method is assigned an anonymous function

car.drive = function() {

this.speed = 60; // from 0 to 60 in a few nano-seconds isn’t bad

}

console.log(car.speed); // prints 0

car.drive(); // execute the drive method

console.log(car.speed); // prints 60

#### The this Keyword and the Global Object

Note the use of the **this**keyword in the drive method. Were the
keyword to be omitted, JavaScript would look for a variable called
“speed” on the global object instead of the “car” object. The global
object is the browser window, so the following two assignments are
equivalent. They both create and/or assign the value to the speed
property on the global object. Whenever an object refers to any of its
members, it must use the **this** keyword to reference them.

car.drive = function() {

speed = 60;

}

car.drive = function() {

window.speed = 60;

}

In fact, the variables we’ve declared in the previous topics have all
been declared on the global object.

var enigma = 42;

console.log(enigma); // prints 42

console.log(window.engima); // prints 42

The same is true for the functions.

var sayHello() {

console.log("Hello");

}

sayHello(); // prints "Hello"

window.sayHello(); // prints "Hello"

sayHello === window.sayHello; // returns true

#### Literal Object Notation

JavaScript has a simpler, terser syntax for creating objects, called
*literal object notation*. Instead of using new Object(), you can use
braces. The following lines perform the same operation: each creates a
new object.

var obj1 = new Object();

var obj2 = {};

Properties and methods can also be declared inside the curly braces.
Remember to use colons (“:”) instead of equal signs (“=”) to assign the
values. Multiple properties can be assigned by separating them with
commas (,).

The following object is equivalent to the car object declared above.

var car = {

speed: 0,

drive: function() {

this.speed = 60;

}

};

Objects declared with literal object notation can be passed to functions
and functions can return them. The following example passes a literal
object to the summarize function. The summarize function returns a new
literal object.

function summarize(details) {

return {

name: details.firstName + " " + details.lastName,

score: details.homeworkGrade \* 0.6 + details.examGrade \* 0.4

}

}

var summary = summarize({

firstName: "John",

lastName: "Smith",

homeworkGrade: 80,

examGrade: 100

});

console.log(summary.name); // prints "John Smith"

console.log(summary.score); // prints 88

The JavaScript interpreter does not always parse code correctly. In the
following example, the interpreter injects a semi-colon after the return
keyword because it mistakenly interprets the opening brace on the next
line as a separate block. Calling this function returns undefined
instead of the expected object.

function getObject() {

return // the interpreter injects a semi-colon right here

{

number: 1

};

}

It is always safe to place the opening brace at the end of the previous
line; the interpreter will not inject semi-colons when they are on the
same line. For consistency and to avoid similar pitfalls elsewhere,
opening braces in JavaScript should always be placed at the end of the
preceding line.

#### Functions Are Objects

Functions and objects in JavaScript have a unique relationship: at a
very deep level, functions are objects. Whenever a function is created
or declared, JavaScript actually creates a **Function** object, which
derives from the **Object** object. This relationship helps explain why
functions are values and not purely structural elements.

But the relationship doesn’t stop there. We’ve seen how simple custom
objects can be created by either calling new Object() or using *literal
object notation*. These objects can be useful, but they have a number of
caveats: they are single-use objects and they cannot share behavior. Two
literal objects that have properties and methods with identical
signatures do not actually share their property and method definitions.
The similarity is superficial.

In the following example, the **createCar** function creates an object
with three members: one property (“speed”) and two methods (“go” and
“stop”). When a “car” object is created, the object’s members are also
created. Every member, including the method functions, is a value and
the JavaScript engine has to allot it some memory. Because none of the
member definitions are shared, every property and every method is
created again for every “car” object. In addition, there is no real
relationship between the two objects.

function createCar() {

var car = {}

car.speed = 0;

car.go = function() {

this.speed = 60;

},

car.stop = function() {

this.speed = 0;

}

return car;

}

var firstCar = createCar();

var secondCar = createCar();

#### Constructors

Note that the previous example relies on the use of a factory method to
create the objects. A factory method (**createCar**) is used to avoid
repeating the code, which is good practice and should be encouraged. But
inside the factory method, the object is created by appending, or
attaching, arbitrary methods and properties. The fact that the factory
method is creating an object that represents a car is completely
contextual. The problem is that the object is anonymous. Other than
defining structure and behavior, classes also name the type of the
object so object creation relies much less on the immediate context.

JavaScript supports creating objects that are not anonymous. The
mechanism relies on the basic principle that functions are actually
objects. Using the **new** keyword with *any function* instructs the
JavaScript engine to create an object named after the function and to
use that function as its constructor.

Creating a simple constructor in JavaScript is as easy as creating a
function. Note that the first letter of the function’s name is a capital
letter. This is a common convention used to denote constructor functions
and is considered best practice.

function Car() {

}

What makes a function a constructor is not the way it is declared, but
the way it is called. To create an object, call the function with the
**new** operator. This instructs the JavaScript engine to create a new
object that uses the function as its constructor.

var firstCar = new Car();

var secondCar = new Car();

One way to add properties and methods to objects created in this way is
to simply define them in the constructor, using the **this** keyword.
We’ve seen earlier that the **this** keyword can be used to add
variables and nested functions to a function. Since functions are
actually objects, adding variables and nested functions is actually the
same thing as adding properties and methods.

We can now replace the factory method used to create the anonymous “car”
objects above with a **Car** object constructor:

function Car() {

this.speed = 0;

this.go = function() {

this.speed = 60;

},

this.stop = function() {

this.speed = 0;

}

}

var firstCar = new Car();

var secondCar = new Car();

Constructors, just like every function, can also receive arguments:

function Car(currentSpeed) {

this.speed = currentSpeed;

}

var firstCar = new Car(0);

var secondCar = new Car(30);

#### The instanceof Keyword

Objects created using a function as a constructor are considered
instances of the type named after the constructor. They can be said to
share an “is” relationship with that type. To test for this
relationship, use the **instanceof** keyword. Note that the keyword can
be used to compare any value with any function; there must be a function
(or an object) on the right side of the operator.

firstCar instanceof Car; // returns true

Car instanceof Object; // returns true because Car "is an" Object

Object instanceof Car; // returns false

#### What is a Prototype?

In most object-oriented languages, classes are used to define the
structure and behavior for objects, so every object of a given class has
all of that classes’ properties and methods. Classes also establish an
inheritance hierarchy, so objects have all the properties and methods of
their class *and* any class they inherit from. JavaScript uses
prototype-based inheritance instead of class-based inheritance. In
*prototypal inheritance*, an object called a *prototype* serves as a
template for other objects based on it. Another way to look at this is
that instead of using a base *class* to define structure and behavior,
JavaScript uses a base *object*, known as a prototype.

Every constructor function has a **prototype** property. By default, the
value is undefined. When a prototype is assigned to a constructor
function, all the objects created using that constructor function share
the behavior and structure of the prototypal object.

function Car() {

this.speed = 0;

}

Car.prototype = {

go: function() {

this.speed = 60;

}

}

var theCar = new Car();

console.log(theCar.speed); // prints 0

theCar.go(); // calls the method defined on the prototype object

console.log(theCar.speed); // prints 60

If multiple objects are created using the **Car** constructor function,
they all share the same *instance* of the **go** method because it is
defined on the prototype. The method is shared among all the derived
objects. And because only one instance of the prototype and its members
is created for all the derived objects, the JavaScript engine consumes
less memory and performs better.

Adding properties to prototypes is tricky and should usually be avoided.
First, since all the derived objects share the same instance of the
prototype object, if any of them change the value of any member
(property or method) of the prototype object itself, it affects all the
other derived objects. So it only makes sense to add constant variables
that are not expected to change the prototype.

Second, specifying properties on the prototype may produce unexpected
results because of the way the **this** keyword works. When the
prototype method **go** is executed in the following example, the
**this** keyword refers to the nonexistent property on the actual object
for which it is called, and not to the property defined on the prototype
object. This causes the **speed** property to be created unexpectedly
and can produce unpredictable results. It is strongly recommended to
always specify variables in the constructor function, unless they
represent constant values.

The built-in **hasOwnProperty** method can be used to test whether the
property is on the actual object or on the prototype.

function Car() {

}

Car.prototype = {

speed: 0, // not recommended

go: function() {

this.speed = 60;

}

}

var theCar = new Car();

console.log(theCar.hasOwnProperty("speed")); // prints false

theCar.go();

console.log(theCar.hasOwnProperty("speed")); // prints true because the
property has been created on theCar, which is probably unintended

JavaScript is a dynamic language, so properties and methods can be added
to a prototype object at any time. These changes affect all the derived
objects. The following example adds a new method (**stop**) after a
derived object has been created and then calls it.

function Car() {

this.speed = 0;

}

Car.prototype = {

go: function() {

this.speed = 60;

}

}

var theCar = new Car();

theCar.go();

console.log(theCar.speed); // prints 60

Car.prototype.stop = function() {

this.speed = 0;

}

theCar.stop();

console.log(theCar.speed); // prints 0

#### Prototype Chains

Deeper hierarchies can be created by setting the prototype of a
constructor function to another object with a prototype. Using a
prototype chain, it is possible to create complex inheritance trees.

function Vehicle() {

this.location = "";

this.arriveAt = function(newLocation) {

this.location = newLocation;

console.log("Arrived at " + newLocation + ".");

}

}

function Car() {

this.driveTo = function(newLocation) {

console.log("Driving down the road…");

this.arriveAt(newLocation); // call a method on the Car's prototype, its
"base" object

}

}

Car.prototype = new Vehicle(); // create the prototype chain

var car = new Car();

car.driveTo("New York"); // call a method directly on the Car object,
prints "Driving down the road…", "Arrived at New York."

console.log(car.location); // access a prototype's property, prints "New
York"

#### Replacing the typeof Operator

The **typeof** operator is used to check the type of a value (or its
container). However, the **typeof** operator often produces
counter-intuitive or inconsistent results that are difficult to use. For
example, when the **typeof** operator is used with a primitive Boolean
value, it returns the name of the primitive type: “boolean”. But when it
is used with a **Boolean** object, it returns the string “object”. This
difference is often at odds with expectations.

typeof true; // returns "boolean"

typeof new Boolean(true); // returns "object"

To achieve parity, an alternative mechanism can be used. Instead of the
**typeof** operator, use a function such as this one:

function getType(value) {

if(someValue === undefined) {

return undefined;

}

else {

return Object.prototype.toString.call(someValue).slice(8, -1);

}

}

console.log(getType(true)); // prints "Boolean"

console.log(getType(new Boolean(true)); // prints "Boolean"

The **call** method used in **getType**causes the JavaScript engine to
execute the **toString** method for the **value** variable. The first
argument to the **call** method is used as the value of the **this**
keyword inside the **toString** method (or whatever method is called in
this manner). This is a useful mechanism to override, or better control,
the value of the elusive **this** keyword.

#### Built-In Objects

JavaScript has a number of built-in object types that provide very
helpful services. The built-in **String**, **Number** and **Boolean**
objects manipulate string, number and boolean values, respectively. In
JavaScript, string, number and boolean types are not objects or classes.
They are *primitive types*. The objects are often referred to as
*wrappers* and provide helpful functionality for manipulating values of
their respective types.

The constructors of the primitive wrapper objects are designed to be
called with and without the **new** keyword. That is, they can be called
as simple functions with a single argument, in which they convert the
argument to their respective primitive value.

console.log(String(5)); // prints the primitive string value "5"

console.log(Number("5")); // prints the primitive numeric value 5

When they are called as constructors, with the **new** keyword, they
create objects that can be used to manipulate their values. All three
objects have a constructor that can accept an optional value. They
evaluate to the empty value of their respective types if no value is
passed to the constructor.

var str = new String("intriguing"); // wraps the string "intriguing"

var num = new Number(5); // wraps the number 5

var bool = new Boolean(); // wraps the Boolean false

All three objects have a **valueOf** method that returns their current
value.

str.valueOf(); // returns "intriguing"

num.valueOf(); // returns 5

bool.valueOf(); // returns false

The object methods of the wrapper objects can be called on values or
variables of the respective primitive types, so the objects are rarely
used directly.

"intriguing".valueOf(); // returns "intriguing"

5.valueOf(); // returns 5

true.valueOf(); // returns true

The **String** object contains several functions that help manipulate
string values, including case conversions (**toLowerCase** and
**toUpperCase**), trimming functions (**trimLeft**, **trimRight** and
**trim**, which clear whitespace from the left, right or both ends of
the string), and many other string manipulations (for example, substring
extraction and string replacement functions).

var str = new String(" too much whitespace ");

str.trim(); // returns “too much whitespace”

The **Math**object provides many mathematical functions and constants,
including the very popular **PI**and **e**constants and the **abs**,
**ceil**, **floor**, **round**, **min**, **max**and trigonometric
functions. Note that the **Math**object is unlike other objects:
instances of the **Math**object cannot be created.

Math.floor(Math.PI); // returns 3

When the **Date** object is created, its default value is a number
representing the current date and time. The object can be queried using
its various get functions.

var date = new Date(); // contains the current date

date.getFullYear(); // returns the current year as a number

date.getHours(); // returns the current hour as a number between 0 and
24

It can also be initialized with a specific date using one of the
constructor variants, its value can be modified using one of the set
functions (**setFullYear**, **setHours**, etc.) and it can parse string
values as dates.

The **Array** object in JavaScript has syntax similar to C\#’s syntax
for value assignment and retrieval using indexers.

myArray[5] = 3; // assigns the value 3 as the 6th item in the array

myArray[5]; // returns the value 3

However, other than the syntax similarity, it behaves very differently.
JavaScript arrays can be created with a constructor:

var items = new Array();

They can be expanded by simply assigning new values at unused indices.

items[3] = "a new value"; // expands the array and assigns the new value
to the array at the specified index

They can be initialized with a default size, for performance, and the
size can later be expanded without difficulty:

var items = new Array(3);

The array can also be initialized with values:

var items = new Array("a", "b", "c");

The items in the array can be of different types:

var items = new Array("a", 1);

An array can be declared with a simpler notation called literal
notation:

var items = ["red", "yellow", "blue"];

In addition, the **Array** object exposes functions that can manipulate
the array. For example, the **push** and **pop** functions expose
stack-like functionality. The **concat** function joins two arrays. The
following example demonstrates the **sort** function:

var items = [5, 4, 3, 2, 1];

items.sort(); // sorts and modifies the array

items; // returns the array [1, 2, 3, 4, 5]

To iterate over an array, use the **for** function, which has basic
syntax identical to C\#.

Slide Content

Instructor Note

**<Add Instructor Notes here\>**

\
 \

Topic Core Content

Topic Title

Scope

Manual Content

#### Function Scope

Scope refers to the rules that govern where a variable or other
construct can be referenced or assigned in the code and is used to
determine how accessible any member property or method is to other
callers.

In JavaScript, only functions determine scope. Since objects are
actually functions, scope is shared by objects as well. However, code
blocks, such as those found in for and while loops, do not specify
scope. This can be quite confusing. The following example illustrates
this behavior.

function loop() {

for(var index = 0; index < 10; index++) {

var current = index;

}

console.log(index); // prints 10 because the loop increments after the
last iteration

console.log(current); // prints 9, the last value visible *inside* the
loop

}

loop();

console.log(index); // raises a ReferenceError because index is
out-of-scope

Both the **index** and **current** variables are visible anywhere inside
the function, including outside the code block. The reason for this is
code blocks do not manage scope. The only construct that has scope in
the example is the **loop** function.

Nested functions can see all the members defined in all the parent
functions. The nested function can see all the variables defined in any
of its outer scopes, including those defined on the global object,
itself a function.

var globalValue = "global";

function parent() {

var parentValue = "parent";

function nested() {

var nestedValue = "nested";

console.log(nestedValue); // prints "nested"

console.log(parentValue); // prints "parent"

console.log(globalValue); // prints "global"

console.log(siblingValue); // raises a ReferenceError because
siblingValue is out-of-scope

}

function sibling() {

var siblingValue = "sibling";

}

nested();

}

parent();

#### Closure

It is very common for functions to return other functions that can be
called later. One way to do this is to simply return another function:

function getSimpleFunction() {

return function() {

var text = "simple function";

console.log(text);

}

}

var simpleFunction = getSimpleFunction(); // the result of
getSimpleFunction is *another function*

simpleFunction(); // prints "simple function"

Another way is to create an object with a method, which is really just a
function, and return that object:

function getObjectWithMethod() {

var text = "object with method";

return {

method: function() {

console.log(text);

}

};

}

var objectWithMethod = getObjectWithMethod(); // the result of
getObjectWithMethod is an object that has another function as a method

objectWithMethod.method(); // prints "object with method"

In these examples, each of the outer functions defines a **text**
variable and then creates a new function that uses the **text**
variable. The new functions are executed *after* the outer functions
exit. Both new functions successfully print out the values of their
respective **text** variables when they are called, even though the
**text** variables are no longer in scope.

This code works because of *closures*. When a function returns another
function, and the second function references any variable defined on the
first function, JavaScript creates a closure. A closure keeps the
variables referenced by the new functions “alive” even after the
original function that defined them is no longer around. Another way to
put it is that a closure keeps the new function’s environment and that
environment contains all the referenced variables, regardless of where
they were defined.

It also does not matter how the new function is created. It can be
returned directly by the outer function. It can be a method of a
returned object. It can be a nested function inside a function that is
returned directly. It can be a value in an array. To create a closure,
any returned function simply has to reference a variable defined in an
outer scope.

In the following example, the “outer” function returns an object that
contains some functions that access the **value** variable defined on
the outer function. The object itself does not have any properties, just
methods that modify or return the **value** variable.

function getCalculatorFor(number) {

var value = number;

return {

add: function(operand) {

value = value + operand;

},

multiply: function(operand) {

value = value \* operand;

},

getValue: function() {

return value;

}

};

}

var calculator = getCalculatorFor(10); // returns an object with several
methods

console.log(calculator.getValue()); // prints 10

calculator.add(5);

console.log(calculator.getValue()); // printse15

calculator.multiply(2);

console.log(calculator.getValue()); // prints30

They can do this because all the functions share the same exact closure,
the same environment.

#### Hoisting

Only functions in JavaScript create scope. Code blocks, including loop
statement, do not. This is why variables declared inside loops can be
seen from anywhere in the function, including locations outside the
loops.

function iterate() {

for(var index = 0; index < 10; index++) {

var current = index;

}

console.log(index); // prints 10, the result of the last increment after
the last iteration

console.log(current); // prints 9, the result of the last iteration

}

iterate();

The **index** and **current** variables are visible outside the for loop
because the for loop’s code block does not create scope. Both variables
belong to the scope created by the **iterate** function, which is why
printing them did not produce a **ReferenceError**. The function can be
rewritten as follows:

function iterate() {

var index;

var current;

for(index = 0; index < 10; index++) {

current = index;

}

console.log(index); // prints 10, the result of the last increment after
the last iteration

console.log(current); // prints 9, the result of the last iteration

}

iterate();

In fact, JavaScript goes a step further. Any variable declared
*anywhere* in the function, not just inside loops and nested code
blocks, is *hoisted*, or lifted up, by the interpreter and declared as
early as it can be in the function. Note the difference between the
**good** variable and the nonexistent **bad** variable in the following
example:

function printValues() {

console.log(good); // prints "undefined", because the variable is
implicitly declared (because it is hoisted) and left unassigned

var good = "Very Good!";

console.log(good); // prints "Very Good!", because the previous
statement assigned a value to the "good" variable

console.log(bad); // raises a ReferenceError, because the "bad" variable
is not declared anywhere in the function

}

printValues();

The first time **good** is printed, it has the value **undefined**,
because it was hoisted: it is implicitly declared at the beginning of
the function and as yet unassigned. The second time **good** is printed,
it has already been assigned a value, so the value is printed. When
**bad** is printed, a ReferenceError is raised because the **bad**
variable has not been declared anywhere in the function. Hoisting only
applies to variables that are actually declared in the function,
regardless of where they were declared.

Hoisting also affects closures. When an outer function declares a
variable and then creates and returns a function that uses the variable,
the closure contains a reference to the variable. The important thing to
note is that hoisted variables can also be referenced by the closure.
Because the closure contains a reference to the variable, the new
function always sees the last value assigned to the variable when the
original function exited.

function outer() {

var inner = function() {

console.log(value);

};

var value = "Hello!";

return inner;

}

var printHello = outer(); // contains the inner function

printHello(); // prints "Hello!"

The call succeeds even though the **inner** function is defined before
the reference variable **value** is declared. There are two reasons for
this: the **value** variable is hoisted so the **inner** function can
“see” it; and although the actual variable value when **inner** is
declared is **undefined**, the **inner** function is called long after
**value** is assigned a value and the **outer** function exits.

Slide Content

Instructor Note

**<Add Instructor Notes here\>**

\
 \

Topic Core Content

Topic Title

The Document Object Model (DOM)

Manual Content

#### The DOM

JavaScript was designed to interact with the HTML on the page. However,
HTML is text and might contain mistakes. HTML’s structure is also rather
difficult to parse. On the one hand, it represents a hierarchical
structure, similar to XML, but on the other hand, the HTML syntax is
very loose and lenient and permits great variation in writing styles.
For example, some elements do not need to be closed, so figuring out
which elements are siblings and which are children can be tricky.

With these and other problems in mind, when browsers parse and render
the HTML, they also create an object model called the *Document Object
Model*, or simply, the *DOM*, that is easier for JavaScript to interact
with. The DOM contains objects that represent all the HTML elements on
the page. The DOM is also structured in a way that mirrors the
hierarchical layout the browser constructed based on the HTML.

The DOM is also an interactive API, so modifying the DOM affects the
rendered document. The DOM exposes all the elements, their attributes
and their styles. It is also possible to remove elements from the DOM
(which removes them from the rendered document and the display) and to
add new elements to the DOM.

#### The window Object

JavaScript is an embedded language hosted by the browser. The browser
exposes a global object, the **window**, which is the most basic
interface between the JavaScript code and the DOM. All the constructors
for the built-in objects, events and APIs are actually defined on the
**window** Object.

In fact, any functions or variables defined outside a function are
actually implicitly members of the **window** object. Whenever a
variable is declared without the **var** keyword, it is added
dynamically as a **window** object property. The example demonstrates
these facts:

var obj = new Object();

obj === window.obj; // returns true because obj is a member of the
window object

obj === this.obj; // returns true because the window object, the global
object, has the current scope

#### The document Object

The **window** object exposes the **document** property, which
represents the root of the DOM and provides access to all the elements
on the page. The **document** property is the DOM analog of the root
**html** element. The document hierarchy is composed of nodes that all
share some behavior and common properties. The root node is no
exception, so the **document** object has an array of attributes on the
**attributes** property that represent the actual attributes of the
<html\> element. It has a **className** property that represents the
**class** attribute, as well as **id**, **name** and **style**
properties and a host of other properties that can be associated with
every element or specifically with the <html\> element. Most of these
properties can be modified by simply assigning them new values.

Every node in the DOM tree contains a number of properties that help
navigate the hierarchy. So every node also has the following properties,
**firstChild** and **lastChild**, **childNodes** (an array of all the
element’s children), and **parentNode**.

The document object also has unique properties specific to it. The
**head** and **body** properties, which represent the **head** and
**body** elements, are two such examples.

#### Finding Elements

DOM nodes also contain methods that are used to navigate the DOM more
quickly. Some of the more commonly used methods are methods that search
for elements on the page: **getElementById**, **getElementsByName**,
**getElementsByTagName** and the new **getElementsByClassName**.

The **getElementById** method returns a single DOM element that has the
id passed as an argument. Because the HTML standard requires the values
of the **id** attributes to be unique in any given document, the method
is designed to return just one element, or null if none are found. The
remaining search methods all return arrays of elements matching the
specified criteria.

The following JavaScript example uses this HTML document:

<html\>

<head\>

<title\>This is a sample page</title\>

</head\>

<body\>

<div id="header"\>This is the page header</div\>

<p\>This is a paragraph</p\>

<p\>This is another paragraph</p\>

</body\>

</html\>

And the JavaScript:

var headerElement = document.getElementById("header"); // finds the
header div and assign it to the variable

headerElement.style.border = "solid 2px green"; // equivalent to
specifying the style="border: solid 2px green" on the element itself

var paragraphs = document.getElementsByTagName("p"); // finds all the p
elements on the page, add them to an array and store the array in the
variable

for(var i = 0; i < paragraphs.length; i++) {

paragraphs[i].style.backgroundColor = "orange"; // equivalent to setting
just the background-color CSS property on each p element

}

The example code shows how the find methods might be used to find and
manipulate the DOM.

The getElementsByClassName method is a new method introduced in HTML5.
It has wide support among modern browsers, but older browsers will not
support it.

#### Manipulating the DOM

As we saw in the above example, changing the styles of elements on the
page is very easy when working with the DOM..

The DOM also has methods that let us add and remove elements from the
tree. For example, we could remove the header **div** above using the
**removeChild** method of the header’s parent.

header.parentNode.removeChild(header);

We can also add new elements very easily. To create an element, we first
have to use the **document.createElement** method and pass it the name
of the element tag we want to create. The **createElement** method is a
factory method that prepares the new element object for us. Once we have
an element, we can add it by calling the **appendChild** or
**insertBefore** methods. The former adds the new element as its last
child and the latter adds it as a child wherever we specify. The
following example creates an **h1** element and adds it before the first
paragraph we retrieved earlier.

var newHeader = document.createElement("h1");

newHeader.innerHTML = "This is the New Header";

document.body.insertBefore(newHeader, paragraphs[0]);

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Working with JavaScript\
 \

Manual Content

#### Adding JavaScript to the Page

##### Inline JavaScript

Aside from properties and methods, the DOM also exposes *events*. Events
are essentially special functions called when certain things happen that
we would like to respond to. For example, we might want to show the user
a message when the user clicks on an element. We can respond to these
events by adding *event handlers*. An event handler is code that
executes when the event occurs.

The first place an event handler can be specified is in the HTML itself.
In the HTML for the element, we can add inline JavaScript code to handle
the event.

<h1 onclick="alert('You clicked on the header!');"\>The Header</h1\>

Technically, we can add as much inline code as we want, as long as
semi-colons properly separate the statements. In practice, we want to
avoid using inline JavaScript in this manner as much as possible. It
makes the code difficult to read, maintain and debug. It also violates
the *Separation of Concerns Principle*, the idea that document behavior
(the JavaScript code) should be separated from the content (the HTML).

##### The script Element

The **script** element is our next option. We can place **script**
elements anywhere in the **head** or **body** elements. On the script’s
**type** attribute, we specify “text/javascript” to let the browser know
what kind of code the **script** element contains. So our equivalent
code might now look like this:

<body\>

<h1\>The Header</h1\>

<script type="text\\javascript"\>

<!--

var header = document.getElementsByTagName("h1")[0];

header.onclick = function() {

alert("You clicked on the header!");

};

// --\>

</script\>

</body\>

We have to find the element and then add the event handler. In this
case, the event handler is an anonymous function that executes the code.

We placed the **script** element at the end of the body because code in
the **script** element is always executed as soon as it is interpreted,
just like the HTML is rendered as soon as it can be, even if the
document has finished loading. If we had placed the **script** element
in the **head** element, it may not have found the **h1** element,
because it may not have been parsed yet.

Finally, because the script is inside the **body** element, we have to
surround the script code with an HTML comment. This prevents browsers
that lack support for JavaScript or browsers that have JavaScript
disabled from showing the content as though it were regular HTML.
Browsers that know JavaScript know to ignore these comments and will
never render the code as text on the page. The last line in the
**script** element also uses a JavaScript comment (//) to prevent the
browser from accidentally reading the closing HTML comment tag dashes as
the subtraction operator.

##### Script Files

Placing the code in a script element is certainly preferable to using
inline code. But the script element only belongs to one page and cannot
be reused across multiple pages. It is also difficult to organize and
maintain JavaScript code interspersed in HTML files. We still haven’t
achieved complete separation of content and behavior. The best option is
to put all the JavaScript code in separate files.

Instead of writing the JavaScript code inside the **script** element, we
write the code in a separate file. To tell the browser to load the
JavaScript file, we add the **src** attribute, which specifies the
JavaScript file URL. This instructs the browser to load the JavaScript
code from that file. The browser will not finish rendering the page
until it loads and executes that JavaScript code, so it still runs
exactly the same as before.

So the **script** element in the HTML file now looks like this:

<body\>

<h1\>The Header</h1\>

<script type="text\\javascript" src="script.js"\></script\>

</body\>

And the JavaScript file **script.js** now contains only the JavaScript
code:

var header = document.getElementsByTagName("h1")[0];

header.onclick = function() {

alert("You clicked on the header!");

};

The code is identical, except that we no longer need HTML markup or the
HTML comments. Only browsers that support JavaScript download the file
and execute it.

Separating all our JavaScript into separate files is a best practice.\
 \

#### IntelliSense

Visual Studio supports IntelliSense for JavaScript. However, since
JavaScript is a dynamic language much of the metadata the IntelliSense
feature uses to discover the available objects, properties, methods, and
other syntactic elements is simply unavailable. Visual Studio does a
reasonable job of estimating with certain code constructs and objects.
For example, it may have good knowledge of some of the built-in objects,
like the **Math** object, but not for custom objects we create.

To help Visual Studio, we can add special comments to the beginning of
our JavaScript code files that tell Visual Studio where it can find
related JavaScript code. Some libraries, like the jQuery library which
is introduced in the next lesson, have very detailed documentation that
Visual Studio can also show us. The comments are only intended to help
the IDE; they have no effect on the code itself or on the browser. To
add a reference to another JavaScript file, add a comment with three
forward slashes (instead of two) to the beginning of a JavaScript file.
Add a **reference** element inside the comment with the path of the
other JavaScript file, as follows:

/// <reference path="jquery-1.5.1-vsdoc.js" /\>

As many lines as needed can be added. This instructs Visual Studio to
use the especially marked-up jQuery documentation code file.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

Ajax and JSON\
 \

Manual Content

#### Overview

Every time a user navigates from one page to another, the browser sends
data to the web server and the web server responds by sending data back
to the browser, including the HTML to render. Most of the data sent to
the web server is metadata that rarely changes from page to page. In
addition, because pages on a single site tend to share a common look and
feel, much of the HTML sent back to the browser by the server is similar
to that already sent for other pages on the same site. Repeatedly
sending all of this redundant data wastes both bandwidth and time, which
can be costly for both the user and the web site’s owners and
detrimental to the user experience.

In addition, navigating from page to page, or refreshing a page (by
pressing F5, for example), often clears the browser window before
showing the new page. This can be disconcerting to users and does not
provide an optimal user experience.

Ajax is a mechanism that lets the web developer use JavaScript to
communicate with the web server directly. It can reduce the amount of
data sent to the web server and back, and improves the user experience
by allowing the developer to keep updating the page dynamically rather
than requiring the user to navigate to a different page or refresh the
page.

The name Ajax was originally coined as an acronym, “AJAX,” that stood
for “**A**synchronous **J**avaScript **A**nd **X**ML”. However, the
technology has evolved over time, so now Ajax:

· Can be used both synchronously and asynchronously

· Does not necessarily require JavaScript (it can be used with VBScript,
for example), though it is still used with JavaScript almost exclusively

· Usually uses JSON (which will be covered shortly) instead of XML

As a result of these changes, it is now most commonly spelled “Ajax”
instead of “AJAX.”

#### Normal Page Retrieval Process

To understand how Ajax works, it is necessary to understand how a page
is ordinarily retrieved. When the user clicks a link in a web page or
types a URL into the browser’s address bar, the browser:

\1. Determines which web server can process the URL

\2. Sends a message, known as a *request*, to the web server that
instructs the web server to retrieve the webpage at the specified URL

\3. Waits for the web server to process the request and send a
*response*, a message containing the HTML to display, back to the
browser

\4. Processes the HTML content and displays the web page

The request is a message the browser sends to the web server, and the
response is a message the web server sends back to the browser. Both
messages have two parts: a set of HTTP headers, and a message body.

· Each HTTP header consists of a name and a value that describes the
message body or instructs the web server or browser how to handle the
message. Headers are used to specify the *MIME type*and encoding of the
message, caching instructions, authentication information, and other
metadata.

· The message body can be almost any data. In the normal page retrieval
process outlined above, the message body is an HTML string. The message
body is optional: most **GET**requests do not send a message body.

The most common HTTP header is the **Content-Type**header, which
specifies the MIME type of the message body. A MIME type is a data
format. The **Content-Type**header uses a two-part designation to
specify the MIME type, written as a type name followed by a slash and a
subtype. Some common MIME types include:

· text/plain – Plain text

· text/html – HTML

· text/css – CSS

· text/javascript – JavaScript

· text/xml – XML

MIME types can also designate binary data, audio and video formats, and
other types of content. A full list of registered MIME types can be
found on the IANA’s MIME Media Types page at [MIME
types](http://go.microsoft.com/fwlink/?LinkId=241724).

During the normal web page retrieval process, a lot of data is sent and
received:

First, the request sent to the web server contains the requested URL as
well as additional metadata, including but not limited to:

· The URL of the current web page

· All the cookies available to the web server

· The supported languages and character sets

· Authorization information

· Information about the browser

When the user submits a form, the same process takes place, except that
the browser also sends the form data. Significantly, the web developer
has almost no control over the data and metadata in requests sent to the
web server. The browser collects all the data and metadata and does not
provide the developer an opportunity to intercept and modify the data
sent to the web server.

Second, the response the server sends back to the browser contains
metadata in addition to the HTML for the web page.

When browsing within a single web site, most of the metadata sent to the
web server or returned to the browser does not change from request to
request – but this data is repeatedly sent anyway. In addition, most web
sites use templates for all or most of their web pages to give them a
consistent look and feel, which also means that much of the HTML content
across the different pages is very similar or identical.

For example, in visiting the home page of Internet Explorer, a user
would type the URL
[**http://windows.microsoft.com/en-US/internet-explorer/products/ie/home**](http://windows.microsoft.com/en-US/internet-explorer/products/ie/home)
into Internet Explorer’s address bar. Internet Explorer then:

\1. Determines that the web server can be found at
**windows.microsoft.com**;

\2. Sends a request to **windows.microsoft.com** to retrieve the web
page at **/en-US/internet-explorer/products/ie/home**;

\3. Waits for the server to send the response containing the HTML;

\4. Processes the HTML content once the response arrives;

\5. And displays the web page.

This entire process is repeated for every link the user clicks on that
web page, including links to web pages on the same site.

Ajax was designed to circumvent the normal page retrieval process. It
gives web developers greater control over the data sent to the web
server, so a web server can be instructed to send only the minimum
amount of data necessary to update an already open page.

#### The XMLHttpRequest object

Ajax is made possible by the **XMLHttpRequest** object, which is a
component that lets JavaScript communicate with the web server in the
background without refreshing the whole page. Because it operates in the
background, users can continue to interact with the web page while
requests are sent and responses are received via the **XMLHttpRequest**
object.

Most recent desktop and mobile browsers support the **XMLHttpRequest**
object, so Ajax can be used on almost any device and platform.

The normal process for working with the **XMLHttpRequest** object is
similar to the page retrieval process, except that the
**XMLHttpRequest**object manages the process instead of the browser. One
way to think about it is that the **XMLHttpRequest** object is like a
“mini-browser” accessible via JavaScript. When JavaScript code needs to
retrieve data from a URL in the background, it creates an
**XMLHttpRequest**object that:

\1. Determines which web server can process the URL

\2. Sends a request to the web server to retrieve the data from the
specified URL

\3. Waits for the web server to process the request and send a response
containing the requested data back to the **XMLHttpRequest** object

\4. Passes the data to a JavaScript function that can process the data
and update the web page

While the **XMLHttpRequest** object waits for the web server to process
the request (in step 3), the user can continue to interact with the
webpage.

The use of an **XMLHttpRequest** object typically consists of three
steps:

\1. Creating and configuring the **XMLHttpRequest** object.

\2. Sending the request to the web server.

\3. Processing the response when it arrives.

##### Creating and Configuring the XMLHttpRequest Object

Before an Ajax request can be sent, an instance of the
**XMLHttpRequest** object has to be created. In browsers that support
HTML5, creating the object is very simple.

var xhr = new XMLHttpRequest();

To configure the created object, specify the HTTP method and the URL
address by calling the **XMLHttpRequest** object’s **open** method.

xhr.open("GET", "/api/GetContent.aspx");

The first argument is the HTTP method, the actual command sent to the
web server that designates the type of operation to perform. For simple
uses, the **GET** method is typically used to retrieve data, and the
**POST** method is used to submit form data.

The HTTP method, also known as a *verb*, is the same used to specify the
**method** attribute of the **form** element covered previously, except
that additional verbs are supported by the **XMLHttpRequest** object
besides just **GET** and **POST**. The other verbs, however, are beyond
the scope of this course.

The second argument is the URL address where the requested content can
be found. It can be the address of almost anything that can return data,
such as another web page, a web service, a text or XML file, or even a
binary file.

Either a relative or absolute URL can be specified, but the browser may
block requests to URL addresses located on other web servers as a
security precaution. There are mechanisms to allow communication with
other web servers, but they are beyond the scope of this course.

Addresses on the Web may change over time, and code for one site may
also be used on another site, so web developers should avoid embedding
the current known web server address in URLs found in JavaScript, HTML,
or server-side code. Instead, web developers should use relative URLs,
such as **scripts/myscript.js**, or rooted URLs that start with a slash
(/), such as **/api/GetContent.aspx**. When the URL is a relative or
rooted URL, the browser automatically sends the request to the current
web site’s web server.

The **GET** method is very often used to search and filter information.
When searching for information, a query string is typically appended to
the URL. For example, a request to retrieve products in a specific
category could look like the following statement. Note the use of the
question mark (?) to separate the query string (category=Games) from the
rest of the URL.

xhr.open("GET", "/Products/Search**?Category=Games**");

The **POST** method is most commonly used to submit forms. Form data can
be sent in a query string, like the filter sent with the **GET** method,
but query strings are inherently insecure because they are part of the
publicly visible URL. In addition, forms may contain files and other
binary data that may not be convenient or easy to send in a query
string. Instead, form data is almost always sent as the message body.

Before a form can be submitted using the **XMLHttpRequest** object, the
web developer has to add to the request metadata specifying that the
data it contains represents form data. Metadata for HTTP requests is
specified using headers that provide information about the message body.
When an ordinary form is submitted, the browser automatically adds a few
headers to the request. But when a form is submitted using Ajax, the web
developer has to add the headers manually.

To add a header, use the **XMLHttpRequest** object’s
**setRequestHeader** method. The method accepts two arguments: the name
of the header and its value. The following example adds the proper
headers to designate the request as a form submission.

xhr.open("POST", "/Products/Create");

xhr.setRequestHeader("Content-Type",
"application/x-www-form-urlencoded");

The **Content-Type** header describes the format of the message body. In
this case, the format is the **x-www-form-urlencoded** MIME type, which
is the MIME type associated with ordinary forms.

##### Sending the Request

Once the request is ready, it can be sent using the **XMLHttpRequest**
object’s **send** method. Requests sent using the **GET** method usually
have no message body, so the method is called with no arguments.

var xhr = new XMLHttpRequest();

xhr.open("GET", "/Products/Search?Category=Games");

xhr.send();

Requests sent using the **POST** method usually send a message body,
which is passed as an argument to the send method. When forms are
submitted, the form data is serialized as (converted to) a query string
(without the initial question mark), which is passed to the send method,
as in the following example.

var xhr = new XMLHttpRequest();

xhr.open("POST", "/Products/Create");

xhr.setRequestHeader("Content-Type",
"application/x-www-form-urlencoded");

xhr.send("Name=My New Game&Category=Games");

This example sends form data serialized as a query string, but any data
can be sent so long as the web server knows how to process it.

The **open** method actually has a third, Boolean argument called
**async** that indicates whether the request is sent synchronously or
asynchronously. The **async** argument is optional and defaults to
**true**, so when the argument is omitted, as in the provided examples,
the request is asynchronous.

· When the request is asynchronous, the **send** method does not block
the execution of code that comes after it, even if the response has not
yet arrived.

· When the request is synchronous (when **async** is **false**), the
**send** method does not end until the response has arrived.

Avoid creating blocking synchronous Ajax requests, which can cause the
UI to behave erratically and may be detrimental to the user experience.

##### Processing the Response

The **XMLHttpRequest** object has a property called **readyState** that
determines the state of the request. The **readyState** property can
have any one of the following values:

· **XMLHttpRequest.UNSENT** (0) – Designates that the object has been
created but not yet been configured, and that the request has not yet
been sent

· **XMLHttpRequest.OPENED** (1) – Designates that the open method has
been called, but that the request has not yet been sent

· **XMLHttpRequest.HEADER\_RECEIVED** (2) – Designates that the request
has been sent and that the response headers (the metadata) have been
received, though the response message body has not fully arrived yet

· **XMLHttpRequest.LOADING** (3) – Designates that the response message
body, which can be large, is currently being received

· **XMLHttpRequest.DONE** (4) – Designates that the response message
body has fully arrived

When the value of the **readyState** property is checked to determine
the current state of the **XMLHttpRequest** object, it is possible to
compare the state to the number or to the constant. However, the
constant is recommended because it makes the code more readable.

For example, to check if the response has finished arriving, avoid
using:

if(xhr.readyState === 4)

Instead, use:

if(xhr.readyState === XMLHttpRequest.DONE)

Whenever the **readyState** property value changes, the
**readystatechange** event occurs. To process the response when it
arrives, add an event handler for the **readystatechange** event, check
if the **readyState** property value is **XMLHttpRequest.DONE**, and
then load the response data and act upon it. The following example
checks the result of the product creation request and shows a dialog box
with the new product’s ID. For this example to work, a web server has to
be able to process the request and return a response, so simply
executing the example as-is without a web server is insufficient.

var xhr = new XMLHttpRequest(); // readyState == XMLHttpRequest.UNSENT

xhr.open("POST", "/Products/Create"); // readyState ==
XMLHttpRequest.OPENED

xhr.setRequestHeader("Content-Type",
"application/x-www-form-urlencoded");

xhr.readystatechange = function() {

if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {

alert("The new product ID is: " + xhr.responseText);

}

};

xhr.send("Name=My New Game&Category=Games");

In the example, an anonymous function is assigned to the
**readystatechange** event, making the function the event handler. When
the **readystatechange** event occurs, the function is called. However,
the function is called for every change, not just when the response
finishes arriving. The **if** statement determines whether the response
has finished arriving by checking if the **readyState** property value
is **XMLHttpRequest.DONE**. It also checks if the request and response
were completed successfully by checking the HTTP status – the value 200
indicates a successful round trip. Finally, the **XMLHttpRequest**
object’s **responseText** property contains the result produced by the
web server.

There are a number of properties that can be used to retrieve the
response or its metadata, depending on the code’s requirements. The
following list enumerates some of them:

· **responseText** – Returns the content of the response, formatted as
text

· **responseXML** – Returns the content of the response, formatted as
XML and loaded into an XML document object

· **responseType** – Returns a string that designates the type of data
stored in the response

· **response** – Returns the content of the response formatted according
to the value of the **responseType** property

· **status** – Returns the HTTP status code for the request

Just as almost any data can be sent to the web server, so can almost any
data be sent back. The **responseType** property is a short string that
designates the type of data. The **responseType** property can have one
of several values, but the most significant is **json**. When the
**responseType** is **json**, the content of the response property is
formatted using a special syntax that can be used to construct objects,
allowing the server to effectively send the client a structured object
instead of text that has to be parsed.

#### JSON

JSON is an acronym for **J**ava**S**cript **O**bject **N**otation. It is
a special format for representing objects and is based on the literal
object notation**covered earlier. JSON is a lightweight format for
representing structured data, designed for sending such data to the web
server and back easily.

Before JSON was used, XML was the most common format for sending
structured data with the **XMLHttpRequest** object. However, XML is a
verbose format, which means that it requires more space and bandwidth to
represent the same data.

The following XML document represents a typical product:

<product id="3"\>

<name\>My Game</name\>

<category\>Games</category\>

<isInStock\>true</isInStock\>

<colors\>

<color\>blue</color\>

<color\>aqua</color\>

<color\>green</color\>

</color\>

</product\>

Using literal object notation, a **product**object representing the same
data can be declared in a fashion that is terser and easier to read:

var product = {

id: 3,

name: "My Game",

category: "Games",

isInStock: true,

colors: [ "blue", "aqua", "green" ]

};

JSON is a subset of literal object notation specially designed for
transport. Unlike literal object notation:

· JSON does not support functions.

· JSON property names must be enclosed in double quotes ("). Single
quotes (') are not supported.

The example **product**object would be declared using JSON as follows:

var product = {

"id": 3,

"name": "My Game",

"category": "Games",

"isInStock": true,

"colors": [ "blue", "aqua", "green" ]

};

Programmers usually do not directly create or modify JSON objects. They
use normal JavaScript objects and convert them to JSON strings before
sending them to the web server. JSON strings sent back from the web
server are immediately converted back to JavaScript objects. To convert
a JavaScript object to a JSON string, use the **JSON.stringify** method.

var json = JSON.stringify({

id: 3,

name: "My Game",

category: "Games",

isInStock: true,

colors: [ "blue", "aqua", "green" ]

});

console.log(json); // will print "{"id":3,"name":"My
Game","category":"Games","isInStock":true,"colors":["blue","aqua","green"]}"

To convert a JSON string back to a JavaScript object, use the reverse
function, **JSON.parse**:

var product = JSON.parse(json);

console.log(product.name); // will print "My Game"

When communicating with the web server using the
**XMLHttpRequest**object, JSON is the most common format used to
transfer information. The following example uses the **XMLHttpRequest**
object to send a JSON string to the web server and process the JSON
response.

var newProduct = {

name: "Awesome Game!",

category: "Games"

};

var xhr = new XMLHttpRequest();

xhr.open("POST", "/Products/Create");

xhr.readystatechange = function() {

if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {

if(xhr.responseType === "json") {

var product = JSON.parse(xhr.response);

alert("The new product ID is: " + product.id);

}

}

};

var json = JSON.stringify(newProduct);

xhr.send(json);

The code in the example never directly edits the JSON string. It
converts the **newProduct** object to a JSON string immediately before
sending it to the web server for processing, and converts the resulting
JSON string to the **product** JavaScript object immediately after the
response arrives.

Slide Content

Instructor Note

Ajax is a complex subject that can take some time to master. This topic
covers only the most basic information needed to use Ajax. Most web
developers do not directly use the **XMLHttpRequest** object; instead
they use a JavaScript library that encapsulates the **XMLHttpRequest**
object and provides a more convenient API. jQuery is one such library.
However, it is important to know how the **XMLHttpRequest** object works
to understand how the different libraries use it.

\
 \

Lesson

Lesson Title

Introduction to jQuery\
 \

Lesson Overview

The jQuery JavaScript library is undoubtedly the most popular JavaScript
library today. It is widely used in web sites and web applications
because of the way it simplifies the use of JavaScript. jQuery provides
useful alternatives for common client-side development tasks, creating
functionality which may not be available or cumbersome to use within the
JavaScript language. It is also a cross-browser JavaScript library which
means that the developer writes code once and targets all the major
browsers.

In this lesson you learn about jQuery, the major jQuery concepts, and
how to use jQuery for common JavaScript functionality.

Lesson Objectives

o Explain the basic jQuery principles to be used in the course

o Explain jQuery major concepts

o Use jQuery selectors

o Apply jQuery functions on the DOM

o Wire JavaScript events using jQuery

Instructor Note

The lesson introduces the students to the jQuery JavaScript library
which is the most popular JavaScript library today. The students are
exposed to the major jQuery library concepts which are its programming
philosophy (Get \>\> Act), the jQuery fluent API and the $() function.
They learn what jQuery selectors are and how to use jQuery common
functions. This lesson won’t discuss Ajax functionality which is
discussed later in the course since there is no server involved up until
module 5. Moreover there are a lot of other jQuery concepts like effects
that aren’t covered in the course. You should encourage the students to
open jQuery documentation and learn more about the library offline
outside the course.

\
 \

Topic Core Content

Topic Title

What is jQuery?\
 \

Manual Content

#### What is jQuery?

jQuery was first announced by John Resig in January 2006. Since then
jQuery has grown to be the most popular JavaScript library in the
JavaScript development world. In 2009 Microsoft announced its support
for jQuery development and added the library to most web application
templates in VS2010.

jQuery includes a very big eco-system which is growing rapidly and
consistently. The main functionality that jQuery provides is
alternatives for common JavaScript development tasks and helps to create
functionality that without it would have been very hard to implement.
During the writing of this course the currently available version of
jQuery is 1.7.2 and it can be downloaded from the main jQuery site –
http://www.jquery.com.

It is very important to understand that jQuery is not a substitute for
knowing JavaScript nor is it a solution to all JavaScript problems. In
order to master jQuery, web developers need to know how JavaScript works
and how to use it correctly.

#### Why Use JQuery?

Consider the following questions:

· How do you locate elements with a specific class?

· How do you apply styles to multiple elements?

· How do you handle events in a cross-browser manner?

· How many hours have you spent dealing with cross-browser issues?

These questions and many other questions about JavaScript can help to
understand the necessity of jQuery and the rationale for using it. \
 \

For example, locating specific class elements , before HTML5 introduced
the getElementsByclassName function, was very cumbersome. To do so the
developer needed to search in each DOM object to see if it contains the
class attribute and if that attribute’s value equals the given class
name. Another example is applying style to multiple elements that could
include many JavaScript statements for such simple and expected
functionality. \
 \

These questions also raise a very difficult issue in web development –
the cross-browser issue. There are many available browsers and the old
HTML4 specifications were not strict enough about how to implement
JavaScript functionality. That led browser vendors to create their own
functionality and made it hard to create web applications that interpret
the same functionality in all browsers. For example, the attachEvent
function in Internet Explorer 6 - Internet Explorer 8 vs.
addEventListener function which was introduced in Internet Explorer 9 is
a known cross-browser issue. Since most browsers used the W3C
specifications with addEventListener and Internet Explorer versions
below 9 did not, to address all browsers the developers needed to check
what functionality was available in each browser before they could use
it. This led to many problems and bugs and made web developers lives
very miserable.\
 \

jQuery address the cross-browser issues using feature detection
techniques. It checks whether a feature is available in the browser
before using it. We discuss feature detection more thoroughly in Module
3.

Slide Content

Instructor Note

You should raise a discussion about the need for libraries like jQuery.

\
 \

Topic Core Content

Topic Title

jQuery Syntax and Major Concepts\
 \

Manual Content

jQuery syntax is very easy to follow. The jQuery object is represented
by the word jQuery or $ sign. The jQuery object is used to retrieve one
or more elements using a specific selector and then performs chained
actions on the selected elements.

For example the following code retrieves all the div elements in the DOM
and hide them:

$("div").hide();

The same example can also be expressed as

jQuery("div").hide();

jQuery use the $ and the jQuery notation to address conflicts with other
frameworks which use the $ sign. When a developer uses such a framework
he can use the jQuery object instead of writing $ and expose it through
jQuery functionality.

Every jQuery action returns the jQuery object which enables the
developer to chain actions and processes much more complicated
functionality on the selected elements.

For example the following code retrieves all the div elements and hide
them all except the first:

$("div").slice(1).hide();

The developer can perform an action on the jQuery object itself such as
iterating an array and performing some functionality on each element:

$.each(array, function (index, element) {

...

});

The three main concepts of jQuery are the Get \>\> Act philosophy, the
$() function and its fluent API.

#### The Get \>\> Act philosophy

When using jQuery the developer first selects an element and then
performs actions on it. The previous slide showed exactly that. Using
such philosophy helps to simplify jQuery use. \
 \

Performing actions that result in reflow (rendering the web page flow
again because of some changes in its style or DOM) should be gathered
together for better performance. This means if the code changes the DOM
or its style then the developer should group these changes together
statement after statement. Doing so helps the browser optimize the web
page changes and results in a smaller reflow process.

#### The $() Function

The $() function is the core of jQuery. It exposes all jQuery
functionality which includes:

· Creating HTML elements on the fly.\
 var newDivElement = $("<div /\>") –creates a new div element in memory

· Manipulating existing DOM elements\
 $(window).width(300) –changes the browser window width to 300 pixels

· Selecting document elements using the jQuery rich selector API\
 $("div").hide(); - selects all the div elements in the DOM

· Many other options such as AJAX functionality, DOM traversal, and DOM
manipulation.

#### Fluent API

jQuery function names express their functionality which makes for more
readable code. Additionally, jQuery’s functions returnthe jQuery object
for each function call. This makes the code very expressive and the code
“directs” its reader as to what it is doing. The following example can
help to understand the concept:\
 \

$("div").show().addClass("main").html("Hello jQuery");

\
 The code selects all the div elements in the web page, displays them
(if they are in hiding mode), adds a CSS class called main to each of
them and inserts into their html the “Hello jQuery” string. The fluent
API helps to understand the code and to figure what the developer wants
to achieve with it.

Slide Content

Instructor Note

The jQuery syntax is very easy to follow. You should emphasize the major
jQuery concepts which are the Get \>\> Act philosophy, the $() function
and the fluent API.

\
 \

Topic Core Content

Topic Title

Getting started with jQuery\
 \

Manual Content

To get started with jQuery first the developer needs to download its
latest version from the jQuery site. Another option is to use Visual
Studio 2010 Web project templates which include jQuery. The problem with
this is that they add jQuery version 1.5.1 and the current jQuery
version is 1.7.2. After retrieving the latest version of jQuery, it
should be added to the web page using the script tag.

Since jQuery is probably used in every page it is good practice to put
its declaration in Master Pages or in the main Layout. This is discussed
in module 9.

After the developer has added the script, jQuery is available to use in
the web page. One other thing that can be very helpful is to add
Intellisense for jQuery. When downloading jQuery the developer should
also download the jquery-[VersionNumber]-vsdoc.js (it is added
automatically in the VS Web project templates). This file includes
documentation which VS is able to read and then add Intellisense which
helps the developer. Adding Intellisense is as simple as dragging the
file into another JavaScript file or writing in the JavaScript file the
following comment:\
 /// <reference path="jquery-1.5.1-vsdoc.js" /\>

After the developer has added IntelliSense he wires up the jQuery
functionality. The appropriate place to do this is after the content of
the page is loaded. To wire up to this event jQuery exposes the
$(document).ready() function. Here is an example of using the ready
function:\
 \

$(document).ready(function() {

// perform the relevant action after the page is ready to use

});

The previous example is equivalent to writing the following shorter code
example:

$(function() {\
 // perform the relevant action after the page is ready to use\
 });

If the developer tries to implement some functionality before the
content has loaded it is not guaranteed to work since not all the DOM
elements would be rendered. HTML5 exposes the DOMContentLoaded function
which is used widely in the course. Underneath, the jQuery ready
function uses the same event so the developer has the option to use each
of the functions.

Not all browsers support the DOMContentLoaded event (for example all IE
versions under IE9 do not support this). jQuery uses feature detection
and if the browser doesn’t implement the DOMContentLoaded event it uses
other means to wire up the ready event.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Demonstration

Demonstration Title

How to get started with jQuery\
 \

Key Points

· Getting the jQuery JavaScript library

· Adding jQuery IntelliSense

· Wiring the ready event

Content

\1. Add the jQuery script to the web page

\2. Add the reference to jQuery documentation for VS2010 IntelliSense

\3. Wire the ready event and add some functionality

\4. Run the web page in the browser

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. In VS2010, create a new ASP.NET **Empty Web Application** called
**HellojQuery**.

\3. Add a new HTML file called **HellojQuery**.

\4. Add a new JavaScript file called **HellojQuery**.

\5. Add the **jquery-1.5.1.js** and **jquery-1.5.1-vsdoc.js**files from
**D:\\Mod01\\Democode\\Assets**.

\6. In the html file add the following script tags inside the head
element:

<head\>

<title\>Hello jQuery</title\>

<script src="jquery-1.5.1.js"\></script\>

<script src="HellojQuery.js"\></script\>

</head\>

\7. Drag the vsdoc file into the surface of the opened HellojQuery.js
file to create the

\
 /// <reference path="jquery-1.5.1-vsdoc.js" /\>

statement and inform the students that you’ve added IntelliSense for
jQuery by doing that.

\8. Add the following code in the HellojQuery.js file to demonstrate the
wiring of the ready event:\
 \

$(document).ready(function() { \
 alert("Hello jQuery ready function");\
 });

\9. Set the HellojQuery.html as the startup page.

\10. Run the application.

Instructor Detailed Steps

\1. If possible, show the students the jQuery web site. \
 Describe to the students that the jQuery site has a very good
documentation library which can help them to learn much more about the
jQuery library.

\2. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\3. In VS2010, create a new ASP.NET **Empty Web Application** called
**HellojQuery**.

\4. Add a new HTML file called **HellojQuery**.

\5. Add a new JavaScript file called **HellojQuery**.

\6. Add the **jquery-1.5.1.js** and **jquery-1.5.1-vsdoc.js**files from
**D:\\Mod01\\Democode\\Assets**.

\7. In the html file add the following script tags inside the head
element:

<head\>

<title\>Hello jQuery</title\>

<script src="jquery-1.5.1.js"\></script\>

<script src="HellojQuery.js"\></script\>

</head\>

\8. Drag the vsdoc file into the surface of the opened HellojQuery.js
file to create the

\
 /// <reference path="jquery-1.5.1-vsdoc.js" /\>

statement and inform the students that you’ve added IntelliSense for
jQuery by doing that.

\9. Add the following code in the HellojQuery.js file to demonstrate the
wiring of the ready event:\
 \

$(document).ready(function() { \
 alert("Hello jQuery ready function");\
 });

\10. Set the HellojQuery.html as the startup page.

\11. Run the application.

12.

Preparation

If possible open the jQuery site:
[jQuery](http://go.microsoft.com/fwlink/?LinkID=241686)

Open VS2010

Instructor Note

The demo should direct the students to where they can get the jQuery
JavaScript library, how to add the jQuery IntelliSense support in Visual
Studio 2010 and how to wire the ready event to start using jQuery.

\
 \

Topic Core Content

Topic Title

jQuery Selectors\
 \

Manual Content

One of the strengths of jQuery is its huge selectors API. This API is
based mostly on CSS Selectors.\
 \

Some of the new CSS3 selectors were adapted from the jQuery selector API
and now are starting to be implemented inside browsers as a
specification.

\
 jQuery selectors main purpose is to help detect and select specific
page elements. The developer can use them to retrieve single or multiple
elements wrapped inside the jQuery object. The selected elements are
manipulated later using jQuery API functions. The number of selectors
combinations is enormous enabling selecting very specific elements very
quickly.\
 There are many options for selections. Some are described below:

\1. Select all the elements in the web page – $("\*").

\2. Select by a specific tag – \
 $("div") – select all the div elements in the web page.

\3. Select by Id – use the \# sign to indicate the id\
 $("\#someId") – select the element with the someId id.

\4. Select by class – use the . sign to indicate a class name\
 $(".main") – select the element with a main class name.

\5. Precise or combination of selectors - \
 $("\#content, .menu") – select the element with a content id that has a
menu class name.\
 $("div.main") – select all the divs with a main class name.

\6. Hierarchy selectors - \
 $("table td") – select all the table td descendants

$("tr \> td") – select all the td children of a tr

$("label + input") – select the input element next to a label element

$("\#content \~ div") – select the div siblings of an element with a
content id

\7. Attribute filters – use the [] signs to indicate an attribute\
 $("div[id]") – select all divs that have an id attribute\
 $("div[dir='ltr']") – select all the divs that have a dir attribute
value equals to ltr

\8. Forms selectors\
 $("input:checkbox") – select all the inputs of type checkbox\
 $(":button") – select all the buttons in the web page

There are also special selectors such as the :contains() function which
can select elements that match the content within the contains
parenthesis, the :even, :odd syntax that can select even or odd rows,
:first-child that selects the first child of every element group and
many more.

Slide Content

Instructor Note

The jQuery selectors are one of the biggest strengths of jQuery. Some
selectors that were created for jQuery were added to the CSS3 selectors
specifications after W3C saw they are widely used. \
 \

\
 \

\
 \

Demonstration

Demonstration Title

How to use the jQuery Selectors API

Key Points

· Getting familiar with the jQuery selectors API

Content

\1. Add markup to the web page

\2. Add jQuery selectors functionality

\3. Run the web page in the browser

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. Open the previous HellojQuery web application

\3. In the HellojQuery HTML file add in the body element a div with an
id of main:

<div id="main"\>\
 </div\>

\4. In the main div, add the following code:

<ul id="ulOfItems"\>

<li\>item 1</li\>

<li class="red"\>item 2</li\>

<li id="item3"\>item 3</li\>

</ul\>

<br /\>

<div\>Hello jQuery</div\>

<div id="result"\></div\>

This creates the page markup containing an unordered list and two divs.

\5. In the HellojQuery.js file add the following code:

var resultDiv;

$(document).ready(function () {

resultDiv = $("\#result");

$("li").each(function () {

resultDiv.text(resultDiv.text() + " " + this.tagName);

});

$("\#item3").each(function () {

resultDiv.text(resultDiv.text() + " " + this.id);

});

$(".red").each(function () {

resultDiv.text(resultDiv.text() + " " + this.tagName);

});

$("ul\#ulOfItems").each(function () {

resultDiv.text(resultDiv.text() + " " + this.id);

});

});

Write to the result div, all tag names of the selected list items , the
id of the selected item3, the tag name li once for the list item with
the red class name and the id of the unordered list, ulOfItems,
retrieved by the precise selector.

\6. Run the web page in the browser to show the results.

Instructor Detailed Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. Open the previous HellojQuery web application

\3. In the HellojQuery HTML file add in the body element a div with an
id of main:

<div id="main"\>\
 </div\>

\4. In the main div, add the following code:

<ul id="ulOfItems"\>

<li\>item 1</li\>

<li class="red"\>item 2</li\>

<li id="item3"\>item 3</li\>

</ul\>

<br /\>

<div\>Hello jQuery</div\>

<div id="result"\></div\>

This creates the page markup containing an unordered list and two divs.

\5. In the HellojQuery.js file add the following code:

var resultDiv;

$(document).ready(function () {

resultDiv = $("\#result");

$("li").each(function () {

resultDiv.text(resultDiv.text() + " " + this.tagName);

});

$("\#item3").each(function () {

resultDiv.text(resultDiv.text() + " " + this.id);

});

$(".red").each(function () {

resultDiv.text(resultDiv.text() + " " + this.tagName);

});

$("ul\#ulOfItems").each(function () {

resultDiv.text(resultDiv.text() + " " + this.id);

});

});

Write to the result div, all tag names of the selected list items , the
id of the selected item3, the tag name li once for the list item with
the red class name and the id of the unordered list, ulOfItems,
retrieved by the precise selector.

\6. Run the web page in the browser to show the results.

Preparation

<Add Preparation Steps here\>

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

jQuery and DOM

Manual Content

After selecting HTML elements using the jQuery selector API the
developer is able to traverse and manipulate these elements using the
jQuery API. These abilities can create an extremely powerful selection
toolset.

DOM Traversal**\
**jQuery includes a variety of DOM traversal functions. These functions
help traverse the DOM tree and later implement needed functionality on
them. It also allows acting upon multiple sets of elements in a single
chain. For example, take a scenario of a web page that includes some div
elements:

<html\>

<head\>…</head\>

<body\>

<div\>…</div\>

<div\>…</div\>

</body\>

</html\>

The developer can use the selectors API to retrieve all the div elements
and then to iterate them using each function and perform an action:

$("div").each(function(i) {\
 alert(i + "=" + $(this).text());\
 });

In the example above, the result of running the code is two alerts with
the index and the div’s text.

There are many traversal functions in the jQuery core such as next,
prev, siblings, children, parent and more. There are also functions that
help to make deeper selections such as find, find elements inside a
selected element, or slice, that returns a slice of the selected
elements array according to the start and end index it receives.\
 The next example shows the use of the find function:

$("p").find(".header").show();

The code selects all the paragraphs and then finds elements with the
class name ‘header’ inside them.

Many of the traversal functions can be replaced with a more specific
selector.

For example the last code example ($(‘p’).find(‘.header’).show();) can
be replaced with $('p.header'). show();

#### DOM Creation

jQuery includes the ability to create the DOM element on-the-fly during
runtime. To create an element the developer passes a string that
includes an HTML snippet to $(). jQuery attempts to create new DOM
elements as described by the HTML snippet and returns a jQuery object
that includes the created elements. The elements are created in memory
and aren’t appended to the DOM. It is the responsibility of the
developer to append the new elements.

Here is an example of creating a new paragraph and appending it to the
body element:

$("<p\>My new paragraph</p\>").appendTo("body");

When creating a new element on-the-fly does not append it to the DOM
until you have finished creating it all and its functionality. Appending
it to the DOM starts a reflow process and if it is then manipulated
again another reflow process is created.

#### DOM Manipulation

jQuery includes many ways to manipulate the DOM. The developer can
change an element’s attributes, style and even remove the entire element
from the DOM. There are many functions in the jQuery API such as html,
text, val, empty, and remove that help the developer achieve almost
every JavaScript DOM manipulation. Here are some examples of using the
manipulation API:\
 $("div").html("<div\>Hello jQuery!</div\>"); inserts a new div with the
“Hello jQuery!” text inside every div in the web page.\
 $(":text[name='txt']").val("Hello"); sets the value of a textbox with
the txt name to Hello.\
 $("p").removeClass("blue").addClass("red"); replaces the blue class
name to red in all web page paragraphs.\
 $("a").attr("href", "home.htm"); changes the attribute href to point to
home.html in all web page a elements.

Some of the functions such as val or html can be used also to fetch the
content of the element. For example the following code fragment puts the
value of the textbox with the txt name in the content variable:\
 var content = $(":text[name='txt']").val()

It is definitely easier to use jQuery to traverse and manipulate the
DOM. Doing the same things with plain JavaScript can be very cumbersome
sometimes and can lead to writing a lot of code.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Demonstration

Demonstration Title

How to Work with the DOM using jQuery

Key Points

· Traverse the DOM using jQuery

· Manipulate the DOM using jQuery

Content

\1. Use the previous demo

\2. Add traversal functionality

\3. Add DOM manipulation functionality

\4. Run the web page

Student Demonstration Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. Open the previous HellojQuery web application

\3. Add the following button at the bottom of the HellojQuery.html file:

<input type="button" id="btnEach" value="Each Function Example" /\>

<br /\>

\4. Add the following JavaScript code in the HellojQuery.js file inside
the ready handler:

$("\#btnEach").click(function () {

$("div").each(function (i) {

alert(i + "=" + $(this).text());

});

});

The code wires a click event to the input with the button type. When the
button is clicked an alert is shown for each div in the page with the
div index and the div text.

\5. Run the web page in the browser.

\6. Click the button to run each functionality.

\7. Add the following paragraph and buttons to the HellojQuery.html
file:

<p\></p\>\
 <input type="button" id="btnCreateParagraph" value="Create Paragraph
Data" /\><br /\>\
 <input type="button" id="btnAppendToUl" value="Append Two List Items
Using appendTo" /\>

\8. Add the following JavaScript code in the HellojQuery.js file inside
the ready handler:

$("\#btnCreateParagraph").click(function () {

$("p").html("<div\>Hello jQuery!</div\>");

});

$("\#btnAppendToUl").click(function () {

$("<li /\>").html("last").appendTo("ul");

$("<li /\>").html("new first").prependTo("ul");

});

The code wires two click event handlers to the buttons. The first
handler adds a new div element with the “Hello jQuery!” text to the
paragraph element. The second event handler creates two list items which
are added as the first and last list items in the unordered list in the
HTML.

\9. Run the web page in the browser.

\10. Click the buttons to run their functionality.

Instructor Detailed Steps

\1. Log on to the virtual machine named **SEA-DEV** as **Admin** with
the password **Pa$$w0rd**

\2. Open the previous HellojQuery web application

\3. Add the following button at the bottom of the HellojQuery.html file:

<input type="button" id="btnEach" value="Each Function Example" /\>

<br /\>

\4. Add the following JavaScript code in the HellojQuery.js file inside
the ready handler:

$("\#btnEach").click(function () {

$("div").each(function (i) {

alert(i + "=" + $(this).text());

});

});

The code wires a click event to the input with the button type. When the
button is clicked an alert is shown for each div in the page with the
div index and the div text.

\5. Run the web page in the browser.

\6. Click the button to run each functionality.

\7. Add the following paragraph and buttons to the HellojQuery.html
file:

<p\></p\>\
 <input type="button" id="btnCreateParagraph" value="Create Paragraph
Data" /\><br /\>\
 <input type="button" id="btnAppendToUl" value="Append Two List Items
Using appendTo" /\>

\8. Add the following JavaScript code in the HellojQuery.js file inside
the ready handler:

$("\#btnCreateParagraph").click(function () {

$("p").html("<div\>Hello jQuery!</div\>");

});

$("\#btnAppendToUl").click(function () {

$("<li /\>").html("last").appendTo("ul");

$("<li /\>").html("new first").prependTo("ul");

});

The code wires two click event handlers to the buttons. The first
handler adds a new div element with the “Hello jQuery!” text to the
paragraph element. The second event handler creates two list items which
are added as the first and last list items in the unordered list in the
HTML.

\9. Run the web page in the browser.

\10. Click the buttons to run their functionality.

Preparation

<Add Preparation Steps here\>

Instructor Note

<Add Instructor Notes here\>

\
 \

Topic Core Content

Topic Title

jQuery and Events

Manual Content

Question:

What type of JavaScript code do you write to handle a button click
event?

Answer:

It depends on the browser the user uses.

Events are used to notify their handlers that the user performed an
action. Every major language implements an event model to interact with
users. Working with events in the past was not an easy task. Browsers
implemented their own event models and functions –behavior that caused
lots of headache for web developers. jQuery provides a cross-browser
event model that can help reduce the complexity of using and wiring
events. The event model is very simple and wiring events is as easy as
telling an element that if it is clicked then it should run some
handler. The following code fragment shows how to wire the click event
to the element with a btn id:

$("\#btn").click(function() {

…

});

The jQuery API includes a large number of events such as click(),
blur(), focus(), dblclick(), mousedown(), mouseup(), and many more.
Besides the event functions the developer can also use the bind function
which executes always and the one function which executes the handler
only once. Both these functions get as parameters the event name to wire
to and the handler which the event executes. Here is an example of using
these functions:

$("div").bind("click", function() {

…

});

$("div").one("click", function() {

…

});

Another option exposed to developers is to remove handlers using the
unbind function. Here is an example of how to use it:

$("div").unbind("click", function() {

…

});

The jQuery event model can simplify the JavaScript code to handle
events. It can reduce errors caused by cross-browser issues regarding
events.

Slide Content

Instructor Note

<Add Instructor Notes here\>

\
 \

Lab

Lab Title

Building a Basic Web Page in the VS2010 SP1 Environment

Virtual Machine Requirements

Virtual machine: SEA-DEV

User name: Admin

Password: Pa$$w0rd

Estimated Time

75 minutes

Scenario

You are informed that the management of Contoso, Ltd has decided to
create a new web application to replace the current one. This web
application should follow the emerging standards of HTML5 and is
expected to be a major milestone in the company’s growth. The project
manager supplies a design document written by the company’s system
analyst and a UI mockup created by the company’s designer.

Objectives

o Become familiar with the VS2010 SP1 environment.

o Use HTML, CSS and JavaScript to create a basic web page

Notes

<Add Lab Notes here\>

Instructor Note

<Add Instructor Notes here\>

\
 \

Lab Exercise

Exercise Title

Writing the Home Page HTML

Exercise Scenario

In this exercise you use the UI mockup image of the homepage created by
the company’s designer as a reference when you create the homepage
structure.

Result

A home page written in HTML containing a game catalog, a game in
spotlight, and cart data.

Instructor Note

Since HTML creation can be cumbersome, the students won’t build the
homepage from scratch. Instead in order to make them practice HTML, they
will build some of the sections in the homepage itself and will get the
structure of the homepage as a skeleton. You should direct the students
to pay attention to the skeleton itself which is built with div elements
in order to divide the web page into sections. If the skeleton had been
built by the students themselves, in the next exercises you will not be
able to guarantee the functionality they need to create will work.

\
 \

Lab Task

Task Title

Create a new Empty Web Application

High Level Task

Detailed Task Steps

Open the starter solution which is located in the
**D:\\Mod01\\Labfiles\\Starter** folder.

\1. Log on to the virtual machine named **SEA-DEV** as **Admin**with the
password **Pa$$w0rd**

\2. Open Microsoft® Visual Studio® 2010.

\3. Open the solution **GameStore.sln** from the
**D:\\Mod01\\Labfiles\\Starter** folder.

Delete

In the **GameStore** solution, create a new Empty Web Application called
**GameStore.Html**.

\1. In the **GameStore** solution, right click the **GameStore**
solution in Solution Explorer.

\2. In the Add menu item choose New Project.

\3. In the Add New Project dialog choose **Visual C\#** under
**Installed Templates** and choose **Web**.

\4. In the Web tab, select the **ASP.NET Empty Web Application**.

\5. Set the name of the web application to **GameStore.Html**.

\6. Press **OK** to create the web application.

Delete

Add

\
 \

Lab Task

Task Title

Create the Solution Structure

High Level Task

Detailed Task Steps

In the **GameStore.Html** web application add the directory structure
and all images which are located in the **D:\\Mod01\\Labfiles\\Starter**
folder.

\1. In the **GameStore.Html**project, right click the
**GameStore.Html**project in Solution Explorer.

\2. In the Add menu item choose New Folder.

\3. Name the created folder **Images**.

\4. In the **GameStore.Html**project, right click the Images folder.

\5. In the Add menu item choose **Existing Item**.

\6. In the **Add Existing Item** dialog box, go to the
**D:\\Mod01\\Labfiles\\Starter \\Images**folder.

\7. Choose all the images in the folder (using CTRL+A).

\8. Click **Add** to add all the images.

Delete

Add

\
 \

Lab Task

Task Title

Create the Homepage HTML File

High Level Task

Detailed Task Steps

In the **GameStore.Html** web application add a new HTML file called
homepage.

\1. In the **GameStore.Html**project, right click the project in the
Solution Explorer.

\2. In the Add menu item choose New Item.

\3. In the Add New Item dialog, choose HTML Page.

\4. In the Name textbox call the page **homepage.html**and**click Add**.

\5. Right click the **homepage.html**.

\6. Press the Set As Start Page menu item to set the homepage as the
start page for the web application.

\7. In the created file replace the existing code with the following
code which is the web page structure:

<!DOCTYPE html\>

<html\>

<head\>

<meta charset="utf-8" /\>

<title\>Contoso, Ltd</title\>

</head\>

<body\>

<div class="container"\>

<p id="logo"\>Contoso, Ltd</p\>

<div class="nav"\>

<!-- unordered list --\>

<a class="go-to-cart-link money-text" href="\#"\>Go to Cart </a\>

</div\>

<div id="slideshow"\>

<img src="images/mpicture.png" alt="Game 1" class="active" /\>

<img src="images/game.jpg" alt="Game 2" /\>

<img src="images/spic1.png" alt="Game 3" /\>

</div\>

<div id="spotlight" class="box"\>

<div class="header"\>

Spotlight

</div\>

<div class="content"\>

</div\>

<div class="footer"\>

Amazing Entertainment

</div\>

</div\>

<div id="cart" class="box narrow"\>

<div class="header"\>

Games in Cart

</div\>

<div class="content"\>

<!-- Cart Table --\>

</div\>

<div class="footer"\>

<a href="\#"\>

<div class="cart-icon"\></div\>

</a\>

</div\>

<div class="drag"\>

<div class="drag-icon"\>

<img src="images/i-icon.png" alt="info" class="info-icon" /\>

</div\>

<div class="text"\>

You can drag items into the cart

</div\>

</div\>

</div\>

<div id="catalog"\>

<!-- Genres --\>

</div\>

<div class="footer"\>

<p class="text"\>Copyright <a class="xbox-link"
href="http://www.xbox.com"\>Xbox Site</a\></p\>

</div\>

</div\>

</body\>

</html\>

This structure is meant to be the basic for building the html web page.
You should explore the structure in order to get a feeling of how to
build a whole web page.

Delete

Add

\
 \

Lab Task

Task Title

Create a simple HTML element

High Level Task

Detailed Task Steps

In the **homepage.html** file, create a genre div and a game element
which includes the game image, the game title, the game price and the
button to add the game to the cart. The genre element should be created
inside the div with **catalog** id. Use the provided designer image in
order to understand how to do so.

\1. In the **homepage.html**, locate the div with **catalog** id.

\2. Inside the div there is an HTML comment: <!-- Genres --\> instead of
this comment you will implement the genres and game details HTML
elements.

\3. Replace the comment with a genre div:

<div class="genre"\></div\>

\4. Inside the genre div add a header div with heading:

<div class="genre"\>\
 <div class="header"\>

<h2\>Strategy Games</h2\>

</div\>\
 </div\>

\5. Inside the genre div and below the header div add a games div:

<div class="genre"\>\
 <div class="header"\>

<h2\>Strategy Games</h2\>

</div\>\
 <div class="games"\>\
 </div\>\
 </div\>

\6. Inside the games div add a game div which includes the game image,
the game title, and a link:

<div class="genre"\>\
 <div class="header"\>

<h2\>Strategy Games</h2\>

</div\>\
 <div class="games"\>\
 <div class="game"\>

<p\>

<img src="Images/game.jpg" alt="Age of Empires" class="thumbnail" /\>

</p\>

<h3 class="game-text"\>Age of Empires</h3\>

<p class="money-text"\>$30</p\>

<div class="button add-to-cart-button"\>

Add to Cart

</div\>

<a class="learn-more" href="\#"\>Learn More \></a\>

</div\>\
 </div\>\
 </div\>

\7. Repeat steps 4-6 and add two more genres: action and simulation and
use the same images which exist in the previous code block.

\8. Save the file by pressing CTRL+S.

\9. Run the web application by pressing CTRL + F5 and take a look at the
homepage you’ve created.

Delete

Add

\
 \

Lab Task

Task Title

Create a simple HTML table element

High Level Task

Detailed Task Steps

Inside the div with **cart** id locate the second and empty div and
create a new HTML table element inside that div. Every row in the table
will hold the game image, a game title and an X image. Use the provided
designer image to understand how to do so.

\1. In the **homepage.html**, locate the div with the <!-- Cart Table
--\> comment.

\2. Instead of the comment create a new HTML table:

<div class="content"\>

<table\>\
 </table\>\
 </div\>

\3. Create a table row to hold the chosen game:

<div class="content"\>

<table\>\
 <tr\>\
 </tr\>\
 </table\>\
 </div\>

\4. Inside the table row create three table cells:

<div class="content"\>

<table\>\
 <tr\>\
 <td\>\
 </td\>\
 <td\>\
 </td\>\
 <td\>\
 </td\>\
 </tr\>\
 </table\>\
 </div\>

\5. Populate the cells with the game title, game image and the X image:

<div class="content"\>

<table\>\
 <tr\>\
 <td\>\
 <img src="images/starwars.jpg" alt="Kinect Star Wars" class="thumbnail"
/\>\
 </td\> \
 <td\>Kinect Star Wars</td\>\
 <td\>

<img src="images/x.jpg" alt="Remove from cart" class="cart-remove-icon"
/\>\
 </td\>\
 </tr\>\
 </table\>\
 </div\>

\6. Repeat step 5 and add two more table rows with the same content.

\7. Save the file by pressing CTRL+S.

\8. Run the web application by pressing F5 and take a look at the
homepage you’ve created.

Delete

Add

\
 \

Lab Task

Task Title

Create a simple un-ordered list

High Level Task

Detailed Task Steps

Inside the div with nav class create an un-ordered list which holds two
list items. Each of the items should hold a link, the first to Home and
the second to Checkout. Use the provided designer image to understand
how to do so.

\1. In the **homepage.html**, locate the div with the nav class which
holds a <!-- unordered list --\> comment.

\2. Instead of the comment create a new unordered list:

<div class="nav"\>

<ul\>\
 </ul\>\
 </div\>

\3. Inside the unordered list create two list items:

<div class="nav"\>

<ul\>\
 <li\></li\>\
 <li\></li\>\
 </ul\>\
 </div\>

\4. Populate the list items with hyperlinks:

<div class="nav"\>

<ul\>\
 <li\><a class="page-link active"
href="Homepage.html"\>Games</a\></li\>\
 <li\><a class="page-link" href="\#"\>Checkout</a\></li\>\
 </ul\>\
 </div\>

\5. Save the file by pressing CTRL+S.

\6. Run the web application by pressing F5 and take a look at the
homepage you’ve created.

Delete

Add

\
 \

Lab Exercise

Exercise Title

Styling the Homepage

Exercise Scenario

In this exercise, you will use CSS to apply styles and layout to the
homepage, in accordance with the UI mockup.

Result

A homepage with a layout and style in accordance with the UI mockup
image document

Instructor Note

Laying out and styling a web page is generally a time-consuming
iterative process. Like the homepage HTML, much of the CSS is supplied
as part of the lab and the students will apply selected styles to fill
in the gaps as they progress. Later exercises embellish the CSS applied
by this lab, so adherence to the lab is recommended to ensure the
expected effects are observed by the students. However, the later
exercises are structured in such a way that the new CSS3 styles will
override some of the styles applied in this exercise, granting students
more freedom to experiment.

\
 \

Lab Task

Task Title

Create the basic theme for the homepage

High Level Task

Detailed Task Steps

Create a new CSS file and add the link element to the homepage.

\1. In the **GameStore.Html** project, right click on the project in the
Solution Explorer.

\2. In the Add menu item choose New Folder.

\3. Name the created folder **Styles**.

\4. In the **GameStore.Html**project right click the **Styles** folder.

\5. In the Add menu item choose **New Item**.

\6. In the Add New Item dialog choose **Style Sheet**.

\7. In the name textbox call the style sheet **theme.css**.

\8. Press the **Add** button to add the new file.

\9. Open the **homepage.html** file.

\10. In the head section add the link to the created style sheet:

<head\>\
 …\
 <link href="Styles/theme.css" rel="stylesheet" type="text/css" /\>\
 </head\>

\11. Save the file by pressing CTRL+S.

Delete

Reset the default browser styles.

\1. Open the **theme.css** file.

\2. Add the default styles for elements:

body

{

font-family: Arial, Helvetica, sans-serif;

text-align: center;

}

a

{

color: white;

text-decoration: none;

}

h1, h2, h3

{

padding: 0px;

margin: 0px;

font-weight: bold;

font-size: 1em;

}

\3. Save the file by pressing CTRL+S.

Delete

Add styles for common classes (.header, .button, .text, etc.)

\4. Add the header class name which gives a white color and bold font
weight to the element using the class:

.header

{

color: white;

font-weight: bold;

}

\5. Add the button class name which styles all the buttons using the
class name:

.button

{

background-image: url(../images/plain-button.png);

text-align: center;

float: left;

height: 28px;

line-height: 28px;

background-repeat: no-repeat;

color: white;

font-weight: bold;

font-size: 16px;

vertical-align: middle;

margin: 0px auto;

cursor: pointer;

width: 126px;

}

\6. Add the text class name which defines the style for texts that are
displayed in the application:

.text

{

color: \#5b5b5b;

font-weight: bold;

font-size: 12px;

text-align: left;

line-height: 15px;

}

\7. Add the container class name which defines how to display the main
div in the application:

.container

{

width: 970px;

height: 100%;

margin: 0px auto;

}

\8. Save the file by pressing CTRL+S.

Delete

Lay out the logo (override the h1 style), the navigation bar and the
footer.

\1. Add the h1 override:

h1

{

text-align: left;

font-size: 32px;

color: \#5c5c5c;

padding: 24px 0px 10px;

}

\2. Add the logo layout using the id selector:

\#logo

{

font-size: 48px;

font-weight: bold;

font-variant: small-caps;

color: \#2a801f;

text-align: left;

padding: 0px 5px;

margin: 10px 0px;

text-shadow: 2px 2px 2px \#000;

}

\3. Add the navigation bar styles:

.nav

{

height: 40px;

width: 100%;

background-color: \#e5e5e5;

margin-bottom: 5px;

}

.nav ul

{

list-style: none;

padding: 0px;

}

.nav ul li

{

display: block;

}

\4. Add the footer styles:

.container \> .footer

{

clear: both;

width: 100%;

background-color: \#e5e5e5;

margin: 50px auto 10px;

float: left;

}

.container \> .footer p

{

padding: 5px 20px;

float: left;

}

\5. Add the following CSS styles to the file:

h2

{

font-size: 18px;

}

table

{

border-collapse: collapse;

border-spacing: 0px;

}\
 \
 .button-bar

{

clear: both;

text-align: left;

padding: 10px;

}\
 \
 .button-bar \> .button

{

margin: 0px 2px;

}\
 \
 .info-icon

{

width: 35px;

height: 35px;

}

.box \> .header

{

height: 38px;

line-height: 38px;

background-color: \#949494;

}

.box.narrow

{

padding-top: 20px;

width: 177px;

}

.xbox-link

{

color: \#2a801f;

text-decoration: underline;

padding-left: 3px;

}

.page-link

{

height: 40px;

width: 180px;

font-size: 19px;

font-weight: bold;

float: left;

padding-top: 9px;

background-repeat: no-repeat;

background-image: url(../images/page-button.png);

}

.page-link.active

{

background-image: url(../images/page-button-active.png);

}

.money-text

{

font-size: 18px;

color: \#2a801f;

font-weight: bold;

line-height: 15px;

padding-top: 15px;

}

\6. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Lay out the main homepage elements\
 \

High Level Task

Detailed Task Steps

Add the skeletal feature-specific CSS files to the project
(slideshow.css, dragdrop.css, spotlight.css, catalog.css and cart.css).

\1. In the **GameStore.Html** project, right click the **Styles**
folder.

\2. In the Add menu item choose New Item.

\3. In the Add New Item dialog choose Style Sheet.

\4. Call the style sheet **slideshow.css**.

\5. Press Add.

\6. Repeat steps 1-6 and create four more style sheets with the
following names: dragdrop.css, spotlight.css, catalog.css and cart.css.

\7. Open the **homepage.html** file.

\8. In the head section add the link to the created style sheet:

<head\>\
 …\
 <link href="Styles/theme.css" rel="stylesheet" type="text/css" /\>

<link href="Styles/slideshow.css" rel="stylesheet" type="text/css" /\>

<link href="Styles/spotlight.css" rel="stylesheet" type="text/css" /\>

<link href="Styles/catalog.css" rel="stylesheet" type="text/css" /\>

<link href="Styles/cart.css" rel="stylesheet" type="text/css" /\>

<link href="Styles/dragdrop.css" rel="stylesheet" type="text/css" /\>\
 </head\>

\9. Save the file by pressing CTRL+S.

Delete

Apply width, height and float styles to the main elements (\#slideshow,
\#spotlight, \#catalog and \#cart) to lay them out correctly.

\1. Open the **slideshow.css** file.

\2. Add the following styles in the slideshow to apply all its styles:

\#slideshow

{

height: 295px;

width: 775px;

float: left;

margin-bottom: 20px;

position: relative;

}

\#slideshow img

{

position: absolute;

left: 0px;

z-index: 1;

width: 775px;

height: 265px;

}

\#slideshow img.active

{

z-index: 3;

}

\#slideshow img.last-active

{

z-index: 2;

}

\3. Save the file by pressing CTRL+S.

\4. Open the **spotlight.css** file.

\5. Add the following styles to the file to apply all the spotlight
styles:

\#spotlight

{

height: 295px;

width: 177px;

float: right;

}

\#spotlight \> .content

{

height: 219px;

color: white;

font-size: 19px;

font-weight: bold;

background-image: url(../images/spotlight.png);

}

\#spotlight \> .footer

{

background: \#2a6da9;

height: auto;

color: white;

font-size: 15px;

font-weight: bold;

}

\6. Save the file by pressing CTRL+S.

\7. Open the **catalog.css** file.

\8. Apply the following style on the catalog element using its id:

\#catalog

{

height: 100%;

width: 775px;

float: left;

margin-bottom: 10px;

}

\9. Save the file by pressing CTRL+S.

\10. Open the **dragdrop.css** file.

\11. Add the following styles to the file to apply all the drag-and-drop
styles:

.drag

{

height: 40px;

float: left;

margin-left: 6px;

}

.drag-icon

{

height: 35px;

width: 35px;

float: left;

}

.drag \> .text

{

width: 120px;

height: 35px;

float: right;

margin: 5px 0 0 2px;

}

\12. Save the file by pressing CTRL+S.

\13. Open the **cart.css** file.

\14. Apply the following style on the cart element using its id:

\#cart

{

height: 100%;

float: right;

}

\15. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Style the cart

High Level Task

Detailed Task Steps

Style the cart

\1. Apply the following style on the cart element:

\#cart \> .content

{

height: 100%;

color: white;

font-size: 19px;

font-weight: bold;

}

\#cart \> .footer

{

width: auto;

height: 38px;

color: white;

font-size: 15px;

font-weight: bold;

background-color: \#949494;

position: relative;

}

\#cart table

{

width: 100%;

height: 100%;

background-color: \#fbfbfb;

border-spacing: 0px;

}

.cart-icon

{

position: absolute;

top: 0px;

right: 0px;

width: 25px;

height: 25px;

background-image: url(../images/cart-icon.png);

background-repeat: no-repeat;

margin: 5px;

}

\#cart .thumbnail

{

width: 48px;

height: 65px;

}

.cart-remove-icon

{

width: 19px;

height: 19px;

}

\#cart .text

{

padding: 0px 4px;

}

.add-to-cart-button

{

background-image: url(../images/cart-button.png);

text-indent: 26px;

float: none;

}

.go-to-cart-link

{

width: 130px;

background-image: url(../images/cart-green-icon.png);

background-repeat: no-repeat;

float: right;

text-align: right;

padding-right: 15px;

}

\2. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Style the catalog\
 \

High Level Task

Detailed Task Steps

Style the genre header

\1. Open the **catalog.css** file.

\2. Apply the following style on the catalog element using its id and
header child element:

.genre \> .header

{

height: 35px;

line-height: 35px;

background-image: url(../images/strip.png);

background-repeat: no-repeat;

cursor: pointer;

}

\3. Save the file by pressing CTRL+S.

Delete

Style the games and lay them out using float

\1. Apply the following style on the games and game elements:

.games

{

padding: 5px 0px;

width: 100%;

display: inline-block;

}

.game

{

width: 245px;

float: left;

margin-left: 6px;

}

.game-text

{

font-size: 18px;

color: black;

font-weight: bold;

line-height: 5px;

}

\#catalog .thumbnail

{

width: 127px;

height: 92px;

}

.learn-more

{

font-size: 12px;

color: \#2a801f;

line-height: 15px;

margin-top: 5px;

}

\2. Save the file by pressing CTRL+S.

\3. Run the application by pressing F5.

Delete

Add

\
 \

Lab Exercise

Exercise Title

Adding JavaScript and jQuery to Make a Dynamic Home Page

Exercise Scenario

In this exercise you will use the homepage functionality document
created by the company’s system analyst to create the homepage behavior.

Result

A home page containing dynamic parts such as collapsible panels and an
image slideshow, manipulated using JavaScript and jQuery, as described
in the design document

Instructor Note

The JavaScript language is not at all easy. During the exercise the
students will be exposed to object creation, wiring events and working
with JavaScript and jQuery to create dynamic functionality. Pay
attention that the created objects will be used in other modules and the
purpose of their creation is to practice object creation.

\
 \

Lab Task

Task Title

Create a new JavaScript file

High Level Task

Detailed Task Steps

In the **GameStore.Html** web application add the **Scripts**directory
and a new JavaScript file called **GlobalFunctions**.\
 Add a script reference to that file in the **homepage.html**.

\1. In the **GameStore.Html**project, right click the project.

\2. In the Add menu item choose **New Folder**.

\3. Name the created folder **Scripts**.

\4. In the **GameStore.Html** project, right click on the **Scripts**
folder.

\5. In the Add menu item choose **New Item**.

\6. In the Add New Item dialog, under the web tab, choose the Jscript
File.

\7. In the name textbox call the JavaScript file **GlobalFunctions.js**.

\8. Press **Add** to add the new file.

\9. Open the **homepage.html**and in the head section add the following
script reference:

<head\>\
 …\
 <script src="Scripts/GlobalFunctions.js"
type="text/javascript"\></script\>

</head\>

\10. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Add jQuery files and jQuery IntelliSense

High Level Task

Detailed Task Steps

Add the jQuery files to the **Scripts** folder. Add the reference
directive inside the **GlobalFunctions** file to include IntelliSense.
Add a script reference to jQuery in the **homepage.html**.

\1. In the **GameStore.Html**project, right click the **Scripts**
folder.

\2. In the Add menu item choose **Existing Item**.

\3. In the Add Existing Item dialog, go to
**D:\\Mod01\\Labfiles\\Starter\\Scripts**folder.

\4. Choose both jQuery files, **jquery-1.5.1.js** and
**jquery-1.5.1-vsdoc.js**, in the folder (using CTRL+A).

\5. Press Add to add all the script files.

\6. Open the **GlobalFunctions.js** file. Add the following line at the
head of the file to enable jQuery IntelliSense:

/// <reference path="jquery-1.5.1-vsdoc.js" /\>

\11. Open the **homepage.html**and in the head section add the following
script reference:

<head\>\
 …\
 <script src="Scripts/jquery-1.5.1.js"
type="text/javascript"\></script\>\
 <script src="Scripts/GlobalFunctions.js"
type="text/javascript"\></script\>

</head\>

\7. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Create simple JavaScript objects

High Level Task

Detailed Task Steps

Create the **Cart** and **Game** JavaScript objects.

\1. In the **GlobalFunctions.js** file Create a Cart object:

var Cart = (function () {

});

\2. Add a games field to the Cart object which will hold an array:

var Cart = (function () {

this.games = new Array();

});

Pay attention to use **this** to create the field.

\3. Create a Game object:

var Game = (function () {

});

\4. Add three fields (gameId, name and imageUrl) to the game object:

var Game = (function () {

this.gameId = 0;

this.name = "";

this.imageUrl = "";

});

Pay attention to the default values every instance of the Game object
will have when it is created.

\5. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Add event listeners to the JavaScript file

High Level Task

Detailed Task Steps

Add an event listener to the DOMContentLoaded event.

\1. Add the following function to the file:

function contentLoaded() {\
 }

\2. Wire the **DOMContentLoaded** event to the **contentLoaded**
function created in step 1 using the following code which should be
written at the end of the file *outside* the **contentLoaded** function:

document.addEventListener("DOMContentLoaded", contentLoaded, false);

\3. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Create the collapsible panel functionality

High Level Task

Detailed Task Steps

Create the functionality of the collapsible panels for the genre div
elements. When the web page loads collapse all the genres panels. Use
the functionality document to understand the functionality demands.

\1. Create the addCollapsiblePanels function that will be used to create
the collapsible panels:

function addCollapsiblePanels() {\
 }

\2. Use jQuery class selector to select all the genres:

function addCollapsiblePanels() {\
 $(".genre")\
 }

\3. Use the jQuery each function to iterate all the selected genres:

function addCollapsiblePanels() {\
 $(".genre").each(function () {\
 });\
 }

\4. Create an element variable and set it to reference the current genre
div:

function addCollapsiblePanels() {\
 $(".genre").each(function () {\
 var element = $(this);\
 });\
 }

\5. For the element find its header using the jQuery selector and wire a
click event to is:

function addCollapsiblePanels() {\
 $(".genre").each(function () {\
 var element = $(this);\
 element.find("\> .header").click(function () {\
 });\
 });\
 }

\6. In the click event find the div with the games class name and toggle
it:

function addCollapsiblePanels() {\
 $(".genre").each(function () {\
 var element = $(this);\
 element.find("\> .header").click(function () {\
 element.find(".games").toggle();\
 });\
 });\
 }

\7. Create the collapseAllPanels function that will be used to collapse
all the games div under the previous created function:

function collapseAllPanels() {\
 }

\8. Use the jQuery selector to select all the elements with the games
class name inside the collapseAllPanels function:

function collapseAllPanels() {\
 $(".games");\
 }

\9. Toggle all the selected elements:

function collapseAllPanels() {\
 $(‘.games’) .toggle();\
 }

\10. Add the call to the functions in the contentLoaded function:

function contentLoaded() {

addCollapsiblePanels();

collapseAllPanels();

}

\11. Save the file by pressing CTRL+S.

Delete

Add

\
 \

Lab Task

Task Title

Create the slideshow functionality

High Level Task

Detailed Task Steps

Create slideshow functionality to replace the images displayed in the
div with a slideshow id. Use the functionality document to understand
the functionality demands.

\1. Create a new function called switchSlide that will be used to switch
slides in the slideshow:

function switchSlide() {\
 }

\2. Use the jQuery selector to select the current active image in the
slideshow:

function switchSlide() {\
 // get the current active image in the slideshow

var active = $("\#slideshow img.active");\
 }

\3. Add code to check if there is an active image and if not set the
last image in the slideshow to be the active image:

function switchSlide() {\
 // get the current active image in the slideshow

var active = $("\#slideshow img.active");\
 // if there is no active image, search for the last image in the
slideshow

// (this will select the current image when the page first loads)

if (active.length == 0) {

active = $("\#slideshow img:last");

}\
 }

\4. Add code to pick the next image to show in the slideshow:

function switchSlide() {\
 // get the current active image in the slideshow

var active = $("\#slideshow img.active");\
 // if there is no active image, search for the last image in the
slideshow

// (this will select the current image when the page first loads)

if (active.length == 0) {

active = $("\#slideshow img:last");\
 }\
 // pick the next image to show in the slideshow

var next = active.next().length ? active.next() : $("\#slideshow
img:first");

}

\5. Add the last active class name to the active image:

function switchSlide() {\
 // get the current active image in the slideshow

var active = $("\#slideshow img.active");\
 // if there is no active image, search for the last image in the
slideshow

// (this will select the current image when the page first loads)

if (active.length == 0) {

active = $("\#slideshow img:last");\
 }\
 // pick the next image to show in the slideshow

var next = active.next().length ? active.next() : $("\#slideshow
img:first");\
 // add the "last-active" style to the current active image to give it a
smaller z-index

active.addClass("last-active");

}

\6. Animate the slide fade out and set the next slide to be the current:

function switchSlide() {\
 // get the current active image in the slideshow

var active = $("\#slideshow img.active");\
 // if there is no active image, search for the last image in the
slideshow

// (this will select the current image when the page first loads)

if (active.length == 0) {

active = $("\#slideshow img:last");\
 }\
 // pick the next image to show in the slideshow

var next = active.next().length ? active.next() : $("\#slideshow
img:first");\
 // add the "last-active" style to the current active image to give it a
smaller z-index

active.addClass("last-active"); \
 // animate the slide fade out and set the next image as the current
active image

next.css({ opacity: 0.0 })

.addClass("active")

.animate({ opacity: 1.0 }, 1000, function () {

active.removeClass("active last-active");

});

}

\7. Create a new function called startSlideShow that will start the
slideshow and switch between slides every 8 seconds or if the slideshow
image is clicked:

function startSlideShow() {

// set the interval to switch between images every 8 seconds

setInterval("switchSlide()", 8000);

// switch slides whenever the slideshow container is clicked

$("\#slideshow").click(function () {

switchSlide();

});

}

\8. Add the call for the function in the contentLoaded function:

function contentLoaded() {\
 startSlideShow();

addCollapsiblePanels();

collapseAllPanels();

}

\9. Save the file by pressing CTRL+S.

\10. Run the web application by pressing F5.

Delete

Add

Module Review

<Add Best Practices here\>\
 \

**Common Issues and Troubleshooting Tips**

**Issue**

**Troubleshooting Tip**

****

<Add Common Issues here\>\
 \

<Add Troubleshooting tips here\>

Delete

Add

Instructor Note

<Add Instructor Notes here\>

\
 \

Discussion Question

Question

<Add Discussion Question here\>

Answer

<Add Answer here\>

Correct Answer With Feedback

<Add Correct Answer with feedback here\>

\
 \

Real-World Issue and Scenario

<Add Real World Issues here\>

\
 \

Tools

<Add Tools here\>


